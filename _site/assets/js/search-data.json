{"0": {
    "doc": "Just the Class",
    "title": "Just the Class",
    "content": "Just the Class is a GitHub Pages template developed for the purpose of quickly deploying course websites. In addition to serving plain web pages and files, it provides a boilerplate for: . | announcements, | a course calendar, | a staff page, | and a weekly schedule. | . Just the Class is a template that extends the popular Just the Docs theme, which provides a robust and thoroughly-tested foundation for your website. Just the Docs include features such as: . | automatic navigation structure, | instant, full-text search and page indexing, | and a set of UI components and authoring utilities. | . ",
    "url": "/",
    
    "relUrl": "/"
  },"1": {
    "doc": "Just the Class",
    "title": "Getting Started",
    "content": "Getting started with Just the Class is simple. | Create a new repository based on Just the Class. | Update _config.yml and README.md with your course information. Be sure to update the url and baseurl. | Configure a publishing source for GitHub Pages. Your course website is now live! | Edit and create .md Markdown files to add more content pages. | . Just the Class has been used by instructors at Stanford University (CS 161), UC Berkeley (Data 100), UC Santa Barbara (CSW8), Northeastern University (CS4530/5500), and Carnegie Mellon University (17-450/17-950). Share your course website and find more examples in the show and tell discussion! . Local development environment . Just the Class requires no special Jekyll plugins and can run on GitHub Pages’ standard Jekyll compiler. To setup a local development environment, clone your template repository and follow the GitHub Docs on Testing your GitHub Pages site locally with Jekyll. ",
    "url": "/#getting-started",
    
    "relUrl": "/#getting-started"
  },"2": {
    "doc": "About",
    "title": "About",
    "content": " ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"3": {
    "doc": "About",
    "title": "Table of contents",
    "content": ". | About | Lecture | Resources | Assignments | . ",
    "url": "/about/#table-of-contents",
    
    "relUrl": "/about/#table-of-contents"
  },"4": {
    "doc": "About",
    "title": "About",
    "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Aliquam ut porttitor leo a diam. Erat nam at lectus urna duis convallis convallis tellus id. Pellentesque elit eget gravida cum sociis natoque penatibus et magnis. Ultrices vitae auctor eu augue ut lectus arcu. Morbi tristique senectus et netus et malesuada. Turpis tincidunt id aliquet risus feugiat in ante. Consequat interdum varius sit amet mattis vulputate enim nulla. Felis eget nunc lobortis mattis aliquam. Eu non diam phasellus vestibulum lorem sed risus. A condimentum vitae sapien pellentesque habitant morbi tristique. Orci dapibus ultrices in iaculis nunc sed augue lacus viverra. Proin sagittis nisl rhoncus mattis rhoncus urna neque. Dictum varius duis at consectetur lorem donec massa sapien. Blandit cursus risus at ultrices mi tempus imperdiet. Laoreet sit amet cursus sit amet dictum sit amet justo. Felis eget nunc lobortis mattis aliquam faucibus. Nam aliquam sem et tortor consequat. ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"5": {
    "doc": "About",
    "title": "Lecture",
    "content": "Tempus iaculis urna id volutpat lacus laoreet non curabitur gravida. Vulputate dignissim suspendisse in est ante in. Massa vitae tortor condimentum lacinia quis vel. Gravida neque convallis a cras semper auctor. Pellentesque eu tincidunt tortor aliquam nulla. Quam adipiscing vitae proin sagittis nisl rhoncus mattis rhoncus urna. Sit amet purus gravida quis blandit turpis cursus in. Porttitor leo a diam sollicitudin tempor. Vel facilisis volutpat est velit egestas dui id ornare. Cum sociis natoque penatibus et magnis. Tristique magna sit amet purus gravida. Nibh sit amet commodo nulla facilisi nullam vehicula. Aenean vel elit scelerisque mauris pellentesque pulvinar pellentesque. Id semper risus in hendrerit gravida. Sit amet justo donec enim diam vulputate ut pharetra sit. Vitae justo eget magna fermentum. Tellus in metus vulputate eu. Pellentesque id nibh tortor id aliquet lectus proin nibh nisl. Etiam erat velit scelerisque in dictum non consectetur a erat. Pellentesque eu tincidunt tortor aliquam nulla. ",
    "url": "/about/#lecture",
    
    "relUrl": "/about/#lecture"
  },"6": {
    "doc": "About",
    "title": "Resources",
    "content": "Lacus viverra vitae congue eu. Suspendisse in est ante in nibh mauris cursus mattis. Nisl vel pretium lectus quam id leo in. Euismod lacinia at quis risus sed vulputate odio. Non enim praesent elementum facilisis. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Id interdum velit laoreet id donec ultrices tincidunt arcu. Urna molestie at elementum eu facilisis sed odio. Auctor urna nunc id cursus metus aliquam eleifend. Volutpat commodo sed egestas egestas fringilla phasellus. Libero nunc consequat interdum varius sit amet mattis. Imperdiet nulla malesuada pellentesque elit eget gravida cum sociis natoque. Tortor vitae purus faucibus ornare suspendisse. Auctor elit sed vulputate mi. ",
    "url": "/about/#resources",
    
    "relUrl": "/about/#resources"
  },"7": {
    "doc": "About",
    "title": "Assignments",
    "content": "Vehicula ipsum a arcu cursus vitae congue. Etiam dignissim diam quis enim lobortis scelerisque fermentum dui. Risus sed vulputate odio ut enim blandit. Aliquam id diam maecenas ultricies mi eget. Id consectetur purus ut faucibus pulvinar elementum integer enim neque. Eget mi proin sed libero enim sed faucibus. Sem integer vitae justo eget magna fermentum iaculis. In mollis nunc sed id semper risus in. Sit amet risus nullam eget felis eget. Mattis ullamcorper velit sed ullamcorper morbi tincidunt ornare massa eget. Nascetur ridiculus mus mauris vitae ultricies leo integer malesuada. Porta non pulvinar neque laoreet suspendisse interdum consectetur libero id. At varius vel pharetra vel turpis nunc eget. Scelerisque purus semper eget duis at tellus. ",
    "url": "/about/#assignments",
    
    "relUrl": "/about/#assignments"
  },"8": {
    "doc": "Announcements",
    "title": "Announcements",
    "content": "Announcements are stored in the _announcements directory and rendered according to the layout file, _layouts/announcement.html. ",
    "url": "/announcements/",
    
    "relUrl": "/announcements/"
  },"9": {
    "doc": "Announcements",
    "title": "Week 1 Announcement",
    "content": "Apr 8 &middot; 0 min read . | Create a new repository based on Just the Class. | Configure a publishing source for GitHub Pages. Your course website is now live! | Update _config.yml with your course information. | Edit and create .md Markdown files to add your content. | . ",
    "url": "/announcements/",
    
    "relUrl": "/announcements/"
  },"10": {
    "doc": "Announcements",
    "title": "Week 0 Announcement",
    "content": "Apr 1 &middot; 0 min read Hello world! . ",
    "url": "/announcements/",
    
    "relUrl": "/announcements/"
  },"11": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": " ",
    "url": "/calendar/",
    
    "relUrl": "/calendar/"
  },"12": {
    "doc": "Calendar",
    "title": "Lab 1: How to build a basic SoC",
    "content": "Aug 28 Section 1 Aug 30 Section 2 Sept 1 Section 3 Sept 9 Lab 1 due ",
    "url": "/calendar/#lab-1-how-to-build-a-basic-soc",
    
    "relUrl": "/calendar/#lab-1-how-to-build-a-basic-soc"
  },"13": {
    "doc": "Calendar",
    "title": "Lab2: GPIOs + Basic MicroBlaze System",
    "content": "Sept 4 Section 1 Sept 6 Section 2 Sept 8 Section 3 Sept 15 Lab 2 due ",
    "url": "/calendar/#lab2-gpios-basic-microblaze-system",
    
    "relUrl": "/calendar/#lab2-gpios-basic-microblaze-system"
  },"14": {
    "doc": "Calendar",
    "title": "Lab 3: Fayetteville Bike Crossing",
    "content": "Sept 11 Section 1 Sept 13 Section 2 Sept 15 Section 3 Sept 22 Lab 3 due ",
    "url": "/calendar/#lab-3-fayetteville-bike-crossing",
    
    "relUrl": "/calendar/#lab-3-fayetteville-bike-crossing"
  },"15": {
    "doc": "Calendar",
    "title": "Lab 4: Timers",
    "content": "Sept 11 Section 1 Sept 13 Section 2 Sept 15 Section 3 Sept 9 Lab 4 due ",
    "url": "/calendar/#lab-4-timers",
    
    "relUrl": "/calendar/#lab-4-timers"
  },"16": {
    "doc": "Calendar",
    "title": "Lab 5: Interrupt Driven Microblaze",
    "content": "Sept 11 Section 1 Sept 13 Section 2 Sept 15 Section 3 Sept 9 Lab 5 due ",
    "url": "/calendar/#lab-5-interrupt-driven-microblaze",
    
    "relUrl": "/calendar/#lab-5-interrupt-driven-microblaze"
  },"17": {
    "doc": "Calendar",
    "title": "Lab 5: Bare Metal RTOS &amp; FreeRTOS",
    "content": "Sept 11 Section 1 Sept 13 Section 2 Sept 15 Section 3 Sept 23 Lab 6 due ",
    "url": "/calendar/#lab-5-bare-metal-rtos-freertos",
    
    "relUrl": "/calendar/#lab-5-bare-metal-rtos-freertos"
  },"18": {
    "doc": "Calendar",
    "title": "Week 1",
    "content": "Mon, Aug 21 Course Introduction Read Ch 1.1, 2.1, 2.2 Download Vivado 2019.1 Weds, Aug 23 Characteristics of Embedded Systems Fri, Aug 25 Basic Software Techniques: Pointer Review HW 1 Assigned ",
    "url": "/calendar/#week-1",
    
    "relUrl": "/calendar/#week-1"
  },"19": {
    "doc": "Calendar",
    "title": "Week 2",
    "content": "Mon, Aug 28 Basic Software Techniques: Bit twiddling in C GPIO data sheet Weds, Aug 30 Parallel Input/Output Fri, Sept 1 More on Basic Software Techniques HW 1 Due ",
    "url": "/calendar/#week-2",
    
    "relUrl": "/calendar/#week-2"
  },"20": {
    "doc": "Calendar",
    "title": "Week 3",
    "content": "Mon, Sept 4 Labor Day Weds, Sept 6 Asynchronous Communications Fri, Sept 8 Asynchronous Communications ",
    "url": "/calendar/#week-3",
    
    "relUrl": "/calendar/#week-3"
  },"21": {
    "doc": "Calendar",
    "title": "Week 4",
    "content": "Mon, Sept 11 Asynchronous Communications Weds, Sept 13 Time Measurement: Hardware Timers Fri, Sept 15 Time Measurement: Hardware Timers ",
    "url": "/calendar/#week-4",
    
    "relUrl": "/calendar/#week-4"
  },"22": {
    "doc": "Calendar",
    "title": "Week 5",
    "content": "Mon, Sept 18 Time Measurement: Polling Weds, Sept 20 Waveform Generation: PWM Fri, Sept 22 Waveform Generation: PWM ",
    "url": "/calendar/#week-5",
    
    "relUrl": "/calendar/#week-5"
  },"23": {
    "doc": "Calendar",
    "title": "Week 6",
    "content": "Mon, Sept 25 : . Weds, Sept 27 : . Fri, Sept 29 : . ",
    "url": "/calendar/#week-6",
    
    "relUrl": "/calendar/#week-6"
  },"24": {
    "doc": "Calendar",
    "title": "Week 7",
    "content": "Mon, Oct 2 : . Weds, Oct 4 : . Fri, Oct 6 : . ",
    "url": "/calendar/#week-7",
    
    "relUrl": "/calendar/#week-7"
  },"25": {
    "doc": "Calendar",
    "title": "Week 8",
    "content": "Mon, Oct 9 : . Weds, Oct 11 Midterm Review Fri, Oct 13 Midterm Exam ",
    "url": "/calendar/#week-8",
    
    "relUrl": "/calendar/#week-8"
  },"26": {
    "doc": "Calendar",
    "title": "Week 9",
    "content": "Mon, Oct 16 : . Weds, Oct 18 : . Fri, Oct 20 : . ",
    "url": "/calendar/#week-9",
    
    "relUrl": "/calendar/#week-9"
  },"27": {
    "doc": "Calendar",
    "title": "Week 10",
    "content": "Mon, Oct 23 : . Weds, Oct 25 : . Fri, Oct 27 : . ",
    "url": "/calendar/#week-10",
    
    "relUrl": "/calendar/#week-10"
  },"28": {
    "doc": "Calendar",
    "title": "Week 11",
    "content": "Mon, Oct 30 : . Weds, Nov 1 : . Fri, Nov 3 : . ",
    "url": "/calendar/#week-11",
    
    "relUrl": "/calendar/#week-11"
  },"29": {
    "doc": "Calendar",
    "title": "Week 12",
    "content": "Mon, Nov 6 : . Weds, Nov 8 : . Fri, Nov 10 : . ",
    "url": "/calendar/#week-12",
    
    "relUrl": "/calendar/#week-12"
  },"30": {
    "doc": "Calendar",
    "title": "Week 13",
    "content": "Mon, Nov 13 : . Weds, Nov 15 : . Fri, Nov 17 : . ",
    "url": "/calendar/#week-13",
    
    "relUrl": "/calendar/#week-13"
  },"31": {
    "doc": "Calendar",
    "title": "Week 14",
    "content": "Mon, Nov 20 : . Weds, Nov 22 Thanksgiving Break! Fri, Nov 24 Thanksgiving Break! ",
    "url": "/calendar/#week-14",
    
    "relUrl": "/calendar/#week-14"
  },"32": {
    "doc": "Calendar",
    "title": "Week 15",
    "content": "Mon, Nov 27 : . Weds, Nov 29 : . Fri, Dec 1 : . ",
    "url": "/calendar/#week-15",
    
    "relUrl": "/calendar/#week-15"
  },"33": {
    "doc": "Calendar",
    "title": "Week 16",
    "content": "Mon, Dec 4 : . Weds, Dec 6 Semester Fri, Dec 8 Reading Day Final Exam 3:00PM - 5PM Final is not comprehensive ",
    "url": "/calendar/#week-16",
    
    "relUrl": "/calendar/#week-16"
  },"34": {
    "doc": "Calendar",
    "title": "Introduction to Java",
    "content": "Sep 28 Java &amp; Git 1.1 Sep 29 SectionIntro to Java Solution Sep 30 Variables &amp; Objects 1.2, 2.1 Oct 1 Lab Intro to Java Oct 2 Tracing, IntLists, &amp; Recursion 2.1 HW 1 due ",
    "url": "/calendar/#introduction-to-java",
    
    "relUrl": "/calendar/#introduction-to-java"
  },"35": {
    "doc": "Calendar",
    "title": "Basic Data Structures",
    "content": "Oct 5 Linked Lists &amp; Encapsulation 3.1, 2.2, 2.3 Oct 6 SectionLinked Lists Solution Oct 7 Resizing Arrays 2.4, 2.5 Oct 8 Lab Resizing Arrays Oct 9 Runtime Analysis 8.1, 8.2, 8.3, 8.4 HW 2 due ",
    "url": "/calendar/#basic-data-structures",
    
    "relUrl": "/calendar/#basic-data-structures"
  },"36": {
    "doc": "PiCaSO",
    "title": "PiCaSO",
    "content": "The dominance of machine learning and the ending of Moore’s law have renewed interests in Processor in Memory (PIM) architectures. This interest has produced several recent proposals to modify an FPGA’s BRAM architecture to form a next-generation PIM reconfigurable fabric. PIM architectures can also be realized within today’s FPGAs as overlays without the need to modify the underlying FPGA architecture. To date, there has been no study to understand the comparative advantages of the two approaches. In this work, we present a study that explores the comparative advantages between two proposed custom architectures and a PIM overlay running on a commodity FPGA. We created PiCaSO, a Processor in/near Memory Scalable and Fast Overlay architecture as a representative PIM overlay. The results of this study show that the PiCaSO overlay achieves up to 80% of the peak throughput of the custom designs with 2.56× shorter latency and 25% – 43% better BRAM memory utilization efficiency. We then show how several key features of the PiCaSO overlay can be integrated into the custom PIM designs to further improve their throughput by 18%, latency by 19.5%, and memory efficiency by 6.2%. ",
    "url": "/projects/picaso/",
    
    "relUrl": "/projects/picaso/"
  },"37": {
    "doc": "PiCaSO",
    "title": "Related Publications",
    "content": ". | MD Arafat Kabir, Ehsan Kabir, Joshua Hollis, Eli Levy-Mackay, Atiyehsadat Panahi, Jason Bakos, Miaoqing Huang, and David Andrews, “FPGA Processor In Memory Architectures (PIMs): Overlay or Overhaul?” The 33rd International Conference on Field-Programmable Logic and Applications (FPL 2023), pp. 1-7, September 2023. arXiv | MD Arafat Kabir, Joshua Hollis, Atiyehsadat Panahi, Jason Bakos, Miaoqing Huang, and David Andrews, “Making BRAMs Compute: Creating Scalable Computational Memory Fabric Overlays,” The 31st IEEE International Symposium On Field-Programmable Custom Computing Machines (FCCM 2023), pp. 1-1, May 2023. IEEE | . Development of PiCaSO is supported by National Science Foundation under Grant No. 1955820. Check out PiCaSO on Github. ",
    "url": "/projects/picaso/#related-publications",
    
    "relUrl": "/projects/picaso/#related-publications"
  },"38": {
    "doc": "Projects",
    "title": "Projects",
    "content": " ",
    "url": "/projects/",
    
    "relUrl": "/projects/"
  },"39": {
    "doc": "Projects",
    "title": "Table Of Contents",
    "content": ". | Current Projects . | PiCaSO | . | Old Projects . | Heterogeneous Extensible MultiProcessor Systems (HEMPS) | Synthesis Free Approach to Domain-Specific Accelerator Design | Self Assembly of MPSoPCs | Heterogeneous Multi- and Many-Core Systems | Cache Design for Solid-State Drives | Programming Models and Runtime Support for GPUs | Hybridthreads | FSMLanguage | Energy Efficiency of MPSoPCs | Hybridthread Compiler | Application-Specific Embedded Manycore System Generation using OpenCL Using OpenCL | . | . ",
    "url": "/projects/#table-of-contents",
    
    "relUrl": "/projects/#table-of-contents"
  },"40": {
    "doc": "Projects",
    "title": "Current Projects",
    "content": " ",
    "url": "/projects/#current-projects",
    
    "relUrl": "/projects/#current-projects"
  },"41": {
    "doc": "Projects",
    "title": "PiCaSO",
    "content": "Processor-in-Memory (PIM) architectures are highly suitable for data-intensive applications like machine learning. While there exists several proposals for custom PIM blocks for FPGAs, they are not currently available in the commodity FPGAs. PiCaSO is a fast and scalable Processor-in-Memory (PIM) overlay architecture. PiCaSO serves as a viable solution for emulating PIM on existing FPGAs, delivering comparable performance to dedicated custom implementations. Development of PiCaSO is supported by National Science Foundation under Grant No. 1955820. Check out PiCaSO on Github. ",
    "url": "/projects/#picaso",
    
    "relUrl": "/projects/#picaso"
  },"42": {
    "doc": "Projects",
    "title": "Old Projects",
    "content": " ",
    "url": "/projects/#old-projects",
    
    "relUrl": "/projects/#old-projects"
  },"43": {
    "doc": "Projects",
    "title": "Heterogeneous Extensible MultiProcessor Systems (HEMPS)",
    "content": "The goal of the Heterogeneous Extensible Multiprocessor System (HEMPS) is to provide a programming model for heterogeneous platforms containing mixes of processors, processors with statically attached accelerators, and processors with dynamic accelerators capable of online reconfiguration. As a result, HEMPS incorporates a runtime system that profiles and adaptively partitions a high-level application onto available heterogeneous resources. ",
    "url": "/projects/#heterogeneous-extensible-multiprocessor-systems-hemps",
    
    "relUrl": "/projects/#heterogeneous-extensible-multiprocessor-systems-hemps"
  },"44": {
    "doc": "Projects",
    "title": "Synthesis Free Approach to Domain-Specific Accelerator Design",
    "content": "The world of software development has the notion of just-in-time compilation, run time binary translation, and language interpretation. There are no such equivalences to increase the productivity or portability of creating new hardware components. Creating a new hardware component requires running through a very time consuming synthesis process. Whereas even re-compiling code can be done in seconds, synthesis takes hours. As we move towards chip heterogeneous multiprocessor systems with more customized accelerator components we need a new flow that eliminates the need to synthesize for every change. We need a new flow that allows software as well as hardware developers to quickly assemble custom hardware accelerators using compilation and run time interpretation techniques. The fundamental question this project seeks to answer is: can software compilation or run time interpretation equivalences replace traditional hardware synthesis for creating custom accelerators? . ",
    "url": "/projects/#synthesis-free-approach-to-domain-specific-accelerator-design",
    
    "relUrl": "/projects/#synthesis-free-approach-to-domain-specific-accelerator-design"
  },"45": {
    "doc": "Projects",
    "title": "Self Assembly of MPSoPCs",
    "content": "When we talk about putting the ability to create a complete MPSoPC at your fingertips, we mean the whole ball of wax; a complete integrated hardware architecture and protocol stack! You can easily create SMP and NUMA Multiprocessor Systems on Chip Architectures using a menu-driven web interface in the Cloud. The produced MPSoPC contains Hthreads which is a Pthreads compliant run time system. You can write Pthreads programs using our compiler/linker, download onto you MPCoPC and run ! . ",
    "url": "/projects/#self-assembly-of-mpsopcs",
    
    "relUrl": "/projects/#self-assembly-of-mpsopcs"
  },"46": {
    "doc": "Projects",
    "title": "Heterogeneous Multi- and Many-Core Systems",
    "content": "Creating heterogeneous SoCs in which each processor has uniform access to operating system services. This project leverages the existing HThreads architecture to allow heterogeneous processors (processors with different ISAs) to communicate and synchronize using a uniform set of OS APIs. Uniform sets of abstractions allow applications to be developed, compiled, and deployed on heterogeneous systems almost as easily as if they were a homogeneous system. Learn more about Heterogeneous_Threads. ",
    "url": "/projects/#heterogeneous-multi--and-many-core-systems",
    
    "relUrl": "/projects/#heterogeneous-multi--and-many-core-systems"
  },"47": {
    "doc": "Projects",
    "title": "Cache Design for Solid-State Drives",
    "content": "A solid-state drive (SSD) is a data storage device that uses solid-state memory to store persistent data with the intention of providing access in the same manner of a traditional block i/o hard disk drive. The de facto memory used in SSDs currently is flash memory. SSDs are potentially more robust than hard disk drives due to the fact that there is no internal moving parts. Further it provides more data access parallelism since multiple flash packages can be accessed simultaneously. However, the flash-based SSD has its own disadvantages as well. First, the write performance is much lower than the read performance. Second, each flash cell can sustain a limited number of writes. This project is intended to address these two issues by proposing an on-board cache for SSDs. Various cache algorithms are to be investigated. A new automatic periodic update (APU) feature is proposed. Results show that the on-board cache can significantly reduce the access latency to SSDs and improve the lifetime of the drives as well. ",
    "url": "/projects/#cache-design-for-solid-state-drives",
    
    "relUrl": "/projects/#cache-design-for-solid-state-drives"
  },"48": {
    "doc": "Projects",
    "title": "Programming Models and Runtime Support for GPUs",
    "content": "Graphics Processing Units (GPUs) are ubiquitous in modern computers. Modern GPUs are very efficient at manipulating computer graphics, and their highly parallel structure makes them more effective than general-purpose CPUs for algorithms where processing of large blocks of data is done in parallel. One of the biggest overhead to use GPUs is the data communication between host CPU and GPU. This overhead can be hidden by overlapping the computation and communication of different GPU contexts. A programming model is proposed to efficiently merge the kernel functions in a multithreaded application into a single context to improve the performance as well as the device occupancy. ",
    "url": "/projects/#programming-models-and-runtime-support-for-gpus",
    
    "relUrl": "/projects/#programming-models-and-runtime-support-for-gpus"
  },"49": {
    "doc": "Projects",
    "title": "Hybridthreads",
    "content": "Hthreads is a computation platform built on top of standard field-programmable gate arrays (FPGAs). This platform is designed as a hardware/software co-designed operating system along with a set of APIs which provide access to the operating system to both hardware and software components. The APIs of hthreads are uniform in policy for both software and hardware threads, although the interfaces used by the two type of threads differ in mechanism. The software thread interface (SWTI) is for use by software components. This interface is designed as a lightweight wrapper around the hardware-based Hthreads operating system and so provides very low-overhead operation. The hardware thread interface (HWTI) is for use by hardware components. This interface is designed in VHDL as a black box hardware component which is capable of communicating with the Hthreads operating system. This design provides seamless integration between hardware components and software components because both the software interface and the hardware interface provide uniform access to the same operating system APIs. This functionality is provided at a very low cost to efficiency because of Hthreads unique hardware based operating system. Learn more about hybridthreads. Learn how to start using hybridthreads. ",
    "url": "/projects/#hybridthreads",
    
    "relUrl": "/projects/#hybridthreads"
  },"50": {
    "doc": "Projects",
    "title": "FSMLanguage",
    "content": "FSMLanguage is a domain-specific language (DSL) for describing finite-state machines. The language was developed in order to create a way for programmers to develop re-targetable representations of FSMs. The FSMLanguage compiler is capable of producing both software- and hardware-implementations of FSMLanguage programs. Both implementation types remain compatible with one another as the communication abstractions that are built in to FSMLanguage are able to cross the hardware/software boundary. Learn more about FSMLanguage. ",
    "url": "/projects/#fsmlanguage",
    
    "relUrl": "/projects/#fsmlanguage"
  },"51": {
    "doc": "Projects",
    "title": "Energy Efficiency of MPSoPCs",
    "content": "Designing new architecture for Hhthreads to improve the energy efficiency but not compromise any performance. To investigate this topic, the research on dynamic power based on Hthreads OS is start. Lean more about the Energy Efficiency of MPSoPCs . ",
    "url": "/projects/#energy-efficiency-of-mpsopcs",
    
    "relUrl": "/projects/#energy-efficiency-of-mpsopcs"
  },"52": {
    "doc": "Projects",
    "title": "Hybridthread Compiler",
    "content": "The HybridThread compiler is designed to allow programmers to develop hardware/software co-designed systems from a single, high-level source language. Learn more about the hybridthread compiler. Hog ARray Processor . We are interested in developing a co-processor that can handle SIMD operations without the need to develop a custom compiler. To achieve this function the SIMD instructions for the co-processor are a mix of MicroBlaze and custom instructions that are all generated by the standard MicroBlaze compiler in XST with some custom libraries. ",
    "url": "/projects/#hybridthread-compiler",
    
    "relUrl": "/projects/#hybridthread-compiler"
  },"53": {
    "doc": "Projects",
    "title": "Application-Specific Embedded Manycore System Generation using OpenCL Using OpenCL",
    "content": "The capacity of Field Programmable Gate-Arrays (FPGAs) is approaching 1 million LUTs. With this capacity, it is possible to create a complete multiprocessor system on a single FPGA device. The traditional approach to designing a system-on-chip is to use the specific tools from the chip vendors. However, this approach generally requires hardware design expertise and lacks the portability. An alternative approach is to generate systems directly from applications written in high-level languages, such as OpenCL. OpenCL is a framework to design parallel applications on multicore/manycore platforms. Both the data parallelism and the architectural hierarchy are explicitly exposed in an OpenCL application. This project focuses on (1) developing a complete flow to generate a multiprocessor system given an OpenCL application, and (2) investigating the high-level synthesis techniques to realize the optimal processor architecture and interconnect infrastructure of the system. ",
    "url": "/projects/#application-specific-embedded-manycore-system-generation-using-opencl-using-opencl",
    
    "relUrl": "/projects/#application-specific-embedded-manycore-system-generation-using-opencl-using-opencl"
  },"54": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "EECS 4213 Computer Architecture",
    "content": " ",
    "url": "/classes/computer-architecture/",
    
    "relUrl": "/classes/computer-architecture/"
  },"55": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Table of contents",
    "content": ". | Introduction | Catalog Description | Textbook | Topics Covered | Class/Assigned Readings | Course Outcomes | Lectures | Homework | . ",
    "url": "/classes/computer-architecture/#table-of-contents",
    
    "relUrl": "/classes/computer-architecture/#table-of-contents"
  },"56": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Introduction",
    "content": "Welcome to EECS 4213 Computer Architecture. It is truly an exciting time to study computer architecture as we are about to engage in a major change in how computers are built ! In this class you will first become familiar with how to measure performance and understand current trends in how the industry is building computers. Then, you will study many of the important historical techniques that the computer industry has developed over the last 20 years for executing multiple instructions concurrently and out of order within scalar cores. This is followed by studying how to combine multiple cores into a multiprocessor system. This will include cache coherency and architecture support for atomic operations. Finally you will study architectures used to accelerate machine learning applications. ",
    "url": "/classes/computer-architecture/#introduction",
    
    "relUrl": "/classes/computer-architecture/#introduction"
  },"57": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Catalog Description",
    "content": "The architecture of modern scalar and parallel computing systems. Techniques for dynamic instruction scheduling, branch prediction, instruction level parallelism, shared and distributed memory multiprocessor systems, array processors, and memory hierarchies. Prerequisite CSCE 2214 . ",
    "url": "/classes/computer-architecture/#catalog-description",
    
    "relUrl": "/classes/computer-architecture/#catalog-description"
  },"58": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Textbook",
    "content": "Computer Architecture. A Quantitative Approach. Sixth Edition, by David A. Patterson and John L. Hennessy, Morgan Kaufmann Publishers, Inc., 2019. ",
    "url": "/classes/computer-architecture/#textbook",
    
    "relUrl": "/classes/computer-architecture/#textbook"
  },"59": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Topics Covered",
    "content": ". | Technology trends and Performance Evaluation | Instruction Level parallelism | Branch Prediction, Dynamic Scheduling, Hardware Speculation | Limitations of Instruction-Level Parallelism | Multithreading and Thread Level Parallelism | Symmetric Shared-Memory Architectures Performance and Synchronization | Distributed Shared Memory and Directory Based Coherence | Vector Processors | SIMD Extensions | Graphics Processor Units (GPUs) | Memory Hierarchies | . ",
    "url": "/classes/computer-architecture/#topics-covered",
    
    "relUrl": "/classes/computer-architecture/#topics-covered"
  },"60": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Class/Assigned Readings",
    "content": ". | Lecture meets M/W/F 3:05 - 3:55 in Blackboard | Readings posted for a week represent the material that will be covered for that week. Part of your preparation for the week is to have performed a first reading of the material in order to familiarize yourself with the topics that will be covered. | . ",
    "url": "/classes/computer-architecture/#classassigned-readings",
    
    "relUrl": "/classes/computer-architecture/#classassigned-readings"
  },"61": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Course Outcomes",
    "content": ". | Knowledge of the history and social impact of high performance computing | Knowledge of Computer Architecture | Ability to apply knowledge of digital logic and computer organization to the design of a computer system | Students are required to apply mathematics in the evaluation of the performance of a computer | Students are required to understand the architecture of a computer system | . ",
    "url": "/classes/computer-architecture/#course-outcomes",
    
    "relUrl": "/classes/computer-architecture/#course-outcomes"
  },"62": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Lectures",
    "content": "Weekly Schedule . ",
    "url": "/classes/computer-architecture/#lectures",
    
    "relUrl": "/classes/computer-architecture/#lectures"
  },"63": {
    "doc": "EECS 4213 Computer Architecture",
    "title": "Homework",
    "content": "Weekly Schedule . ",
    "url": "/classes/computer-architecture/#homework",
    
    "relUrl": "/classes/computer-architecture/#homework"
  },"64": {
    "doc": "Advanced Computer Architecture",
    "title": "Advanced Computer Architecture",
    "content": " ",
    "url": "/classes/advanced-computer-architecture/",
    
    "relUrl": "/classes/advanced-computer-architecture/"
  },"65": {
    "doc": "Lab 2",
    "title": "Lab 2: GPIO Peripherals",
    "content": "Redownload the starter project before attempting this lab. The new starter project incorporates the following changes: . | The AXI SmartConnects are replaced with AXI InterConnects. The AXI SmartConnects’ internal circuitry does not adapt to accommodate addition of new peripherals in this and potentially future labs. This is either by design or a bug in the IP… | An additional AXI Instruction port on the MicroBlaze. We’ll need this later in the semester when we move our applications from local memory to DDR memory. | . Things to do before you start this lab: . | Add the UARTLite IP to your design. Following instructions in Lab 1: Vivado - Generating a bitstream (4). | Assign an address to the UARTLite IP in the “Address Editor” window. | Create an HDL wrapper for your block design. | . ",
    "url": "/classes/embedded-systems/labs/lab2/#lab-2-gpio-peripherals",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/#lab-2-gpio-peripherals"
  },"66": {
    "doc": "Lab 2",
    "title": "Introduction",
    "content": "In lab 1, we started with a basic MicroBlaze SoC, and we added a UART controller which gave us the ability to see the output of our applications. We want to do more with our SoC and the peripherals built into the Arty development board. Therefore, in lab 2, we will add two GPIO controllers to gain access to buttons, switches, and LEDs on our development board. After adding the GPIO controllers, we will synthesize our design and generate a new bitstream. Some boilerplate code is supplied that demonstrates how to connect push button inputs to the green LEDs. When a button is pressed, the corresponding LEDs on the opposite side of the board will light up. You will tinker with the supplied code, and observe how the pointers created are used to perform memory-mapped IO. From there, you will build on the supplied code to add support for the 4 switches on the Arty board and make them control the corresponding RGB LEDs. In order to complete this laboratory successfully, you will need to understand the workings of the GPIO peripheral by reading the GPIO (General Purpose Input/Output). ",
    "url": "/classes/embedded-systems/labs/lab2/#introduction",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/#introduction"
  },"67": {
    "doc": "Lab 2",
    "title": "Project Assignment",
    "content": ". | Create a new application project within SDK to upload to the Arty development board: . | Copy and paste the demo C code into your application | Load the demo code onto the Arty to observe the pointers in action | . | Add to the existing code to create the following functionality: . | When SW0 (far right) switch is in the up position, LD0 (far right RGB LED) will glow white. | When SW1 switch is in the up position, LD1 will glow white. | When SW2 switch is in the up position, LD2 will glow white. | When SW3 (far left) switch is in the up position, LD3 (far left) will glow white. | When the respective switch is down position, the respective LED will turn off. | Just like the buttons in the demo code, when the status of the switches changes, print to the console the current state of the switch register. | . | Please allocate enough time outside of class to read and understand the project and the workings of the GPIO. | . ",
    "url": "/classes/embedded-systems/labs/lab2/#project-assignment",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/#project-assignment"
  },"68": {
    "doc": "Lab 2",
    "title": "Directions",
    "content": "Vivado - Block Design: . | In Vivado, open the “Block Design” from the “Flow Navigator” window. | Double-click on the “microblaze_0_periph” AXI SmartConnect and change “Number of Master Interfaces” to (3). Click “OK” to close the dialog window. You should see two additional ports appear, “M01_AXI” and “M02_AXI”. | Use the “+ Add IP” feature to add the AXI GPIO IP to your design: . | Right-click on the “S_AXI” port on the GPIO controller and select “Make Connection…”. | Choose “M01_AXI” in the “Make Connection” window and click “OK” to make the connection. | Select “Run Connection Automation”. Then select “s_axi_clk” and set “Clock Source:” to “/mig_7series_0/ui_clk (81 MHz). | Double-click on the AXI GPIO IP to open the “Re-Customize IP” window. | Set the GPIO interface to “led_4bits” and GPIO2 to “push_buttons 4bits”. Click “OK” to exit the window. | Finally, select “Run Connection Automation” again, and select both GPIO and GPIO2 interfaces. Click “OK” to automate the connections. | Use the “Regenerate Layout” button to reorganize things in your block design. | . | Add another AXI GPIO controller to your design: . | This time, connect the “S_AXI” port to “M02_AXI” port on “microblaze_0_periph”. | Use the same 81 MHz clock you used earlier. | Then connect GPIO and GPIO2 interfaces to “rgb led” and “dip switch 4bits” respectively. | . | Use the “Address Editor” window to assign addresses to the GPIO IPs you just added. | Save your block design and generate a new bitstream. | Export your hardware, making sure you include the bitstream and Launch the SDK. | . SDK - Creating Software Project: . // GPIO Tutorial Using Pointers /* * Because printf utilizes a UNIX-like streaming interface that has a buffer, * xil_printf is preferred as it has a smaller overhead (1KB), no buffer (it * prints immediately), but doesn't support printing floats or long long types. */ #include \"xil_printf.h\" /* * Define statements: These statements are known as \"preprocessor directives\" * as they are essentially macros that are replaced with their values before * compilation. These are NOT global variables, just helpful values to refer to * constant values. It's a common/best practice to make these macros in CAPS. * * Again, DO NOT use them in place of variable declarations. * * It's common in embedded systems to have a \"board.h\" or \"gpio.h\" header file * referenced that just has all of the useful registers #defined for you. */ #define AXI_GPIO_0_BASE_ADDR 0x40000000 #define GREEN_LEDS_BASE_ADDR (AXI_GPIO_0_BASE_ADDR) #define PUSH_BTNS_BASE_ADDR (AXI_GPIO_0_BASE_ADDR + 8) #define GREEN_LEDS_REG (unsigned *)(GREEN_LEDS_BASE_ADDR) #define PUSH_BTNS_REG (unsigned *)(PUSH_BTNS_BASE_ADDR) int main(void) { // Data and tristate register ptrs for the 4 green LEDs on the Arty board unsigned *greenLEDsData = GREEN_LEDS_REG; unsigned *greenLEDsTri = GREEN_LEDS_REG + 1; // Data and tristate register ptrs for the 4 push buttons on the Arty board unsigned *buttonsData = PUSH_BTNS_REG; unsigned *buttonsTri = PUSH_BTNS_REG + 1; // Let's display our addresses now to see what the macros did: // You'll note the tri-state ptrs have an offset of 4 from the \"+ 1\" above. // This is because the size of an integer takes up 4 bytes, so every + 1 is // really addr + sizeof(int). You can use any base to increment the numbers print(\"\\r\\nBegin...\\r\\n\\r\\n\\tRegister Offsets:\\r\\n\"); xil_printf(\"\\tgreenLEDsData register \\t= 0x%08x\\r\\n\", (int)greenLEDsData); xil_printf(\"\\tgreenLEDsTri register \\t= 0x%08x\\r\\n\", (int)greenLEDsTri); xil_printf(\"\\tbuttonsData register \\t= 0x%08x\\r\\n\", (int)buttonsData); xil_printf(\"\\tbuttonsTri register \\t= 0x%08x\\r\\n\", (int)buttonsTri); // Set the tri-state direction of the AXI_GPIO_0 pins. // Buttons = inputs, LEDs = outputs // (input = high, output = low) *greenLEDsTri = 0x0; *buttonsTri = 0xF; // Used to determine if the program should print to the console int oldButtonsData = 0; // Infinite loop while(1) { // Set the LED register to be the same as the buttons' current reading *greenLEDsData = *buttonsData; // To avoid spamming the COM terminal with each loop, let's only print if the // status of the buttons register has changed: if (*buttonsData != oldButtonsData) { oldButtonsData = *buttonsData; xil_printf(\"buttonsData register: 0x%08x\\r\\n\", *buttonsData); } } return 0; } . | Create a new application project: . | Give your application a name (e.g. lab2). | For “Board Support Package:”, select “Create New”. | On the next page, select “Empty Application”, and select “Finish”. | Right-click on “lab2/src”, and select “New &gt; Source File”. | Enter “main.c” in “Source File:” and select “Finish”. | Copy the example code into your “main.c” file. | Program the FPGA and run the application to see the green LEDs respond to button presses. | . | Add your own code to achieve similar behavior with the dip switches and RGB LEDs: . | When SW0 (far right) switch is in the up position, LD0 (far right RGB LED) will glow white. | When SW1 switch is in the up position, LD1 will glow white. | When SW2 switch is in the up position, LD2 will glow white. | When SW3 (far left) switch is in the up position, LD3 (far left) will glow white. | When the respective switch is down position, the respective LED will turn off. | Just like the buttons in the demo code, when the status of the switches changes, print to the console the current state of the switch register. | . | . Hints: . | For RGB LEDs and dip switches, find the memory address of “axi_gpio_1” in “base_soc_wrapper_hw_platform_0/system.hdf” file. Alternatively, you can find the address in the “Address Editor” window in Vivado. | Unlike the green LED register, which is only 4 bits wide, the RGB LED register is 12 bits wide. Starting from the MSB (Most Significant Bit), each LED occupies 3 bits - 1 for each of the RGB (Red, Green, and Blue) channels. The first 3 bits control the right-most LED (LD0). To turn LD0 white, write 1’s to all three color channels (i.e. 0b111 or 0x7). | You can use bit-wise boolean operations to toggle bits in a register. Refer to class slides on bit twiddling in C. | . ",
    "url": "/classes/embedded-systems/labs/lab2/#directions",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/#directions"
  },"69": {
    "doc": "Lab 2",
    "title": "Submission",
    "content": ". | Prepare a lab report, and give an account of what you did to complete the lab. | In your lab report, include a screenshot of the 2 AXI GPIO controllers you added to your design. | Submit your code file. | . ",
    "url": "/classes/embedded-systems/labs/lab2/#submission",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/#submission"
  },"70": {
    "doc": "Lab 2",
    "title": "Prelab Assignment",
    "content": ". | Read the AXI GPIO Datasheet. Familiarize yourself with all the accessible registers inside the IP, and their offsets from the base address. | . ",
    "url": "/classes/embedded-systems/labs/lab2/#prelab-assignment",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/#prelab-assignment"
  },"71": {
    "doc": "Lab 2",
    "title": "Lab 2",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab2/",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/"
  },"72": {
    "doc": "Lab 5",
    "title": "Lab 5: Interrupt Driven MicroBlaze System",
    "content": "The goal of these labs is to become familiar with the idea of interrupt-based processing techniques using the MicroBlaze processor. A base system will be built that utilizes an interrupt controller to allow for multiple interrupt sources along with a set of interrupt sources. The interrupt sources will include a timer as well as a software interrupt. After understanding what an interrupt does and how to properly implement them, we will then return to the bike trail crossing project and modify the design to use interrupts. You covered interrupts in class exactly as they work with the MicroBlaze. You can refer to Dr. Andrews’ slides from lecture if you have conceptual misunderstandings. ",
    "url": "/classes/embedded-systems/labs/lab5/#lab-5-interrupt-driven-microblaze-system",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#lab-5-interrupt-driven-microblaze-system"
  },"73": {
    "doc": "Lab 5",
    "title": "Lab Directions",
    "content": "For this lab, you will explore the use of software interrupts and timer interrupts in example programs and then you will modify the design of the bike trail traffic crossing signal to rely on interrupts rather than polling to see if the timer has completed. To keep the design consistent between all students for grading purposes, the final design should contain/do the following: . | Display a green (RGB) output on the display when no bikers or walkers are trying to cross the street. | Display a flashing red output on the display immediately after any of the tactile push buttons are pressed. | This stage should last a total of 6 seconds | The amount of time the LED should be on or off in the flashing stage should be 0.5 seconds. (e.g.: 0.5s on, 0.5s off, 0.5s on, …) | If the button is pressed during this stage, the 6 second timer should reset back to zero and the LEDs should blink for another 6 seconds. This is the only stage where this happens | . | After the LEDs have flashed red for 6 seconds, the traffic signal should display the red LEDs for exactly 4 seconds | After the solid red stage, the red LEDs should then flash red again for 6 seconds. A button press here should not affect nor reset any stage countdown timer. | . ",
    "url": "/classes/embedded-systems/labs/lab5/#lab-directions",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#lab-directions"
  },"74": {
    "doc": "Lab 5",
    "title": "Background",
    "content": "The MicroBlaze processor has only a single interrupt port, called the Interrupt port. This port is a 1-bit signal that can be configured to be either edge- or level-triggered. A multiplexer must be used in order to create a MicroBlazebased system that has multiple interrupt sources. A multiplexer built specifically to handle interrupt sources is often referred to as an interrupt controller, or often, a programmable interrupt controller (PIC). The following diagram demonstrates how an interrupt controller is used to multiplex many interrupt sources onto a single interrupt request line. Interrupt.jpg . In this type of situation the processor must be able to determine which interrupts have fired and need servicing. Most interrupt controllers contains registers that allow a processor to query the following: . | Which interrupts are enabled? . | Interrupt Enable Register (IER). | . | Which interrupts have fired and need servicing? . | Interrupt Service Register (ISR). | . | Which interrupts need to be cleared? . | Interrupt Acknowledge Register (IAR). | . | . When the processor receives an interrupt, it must first look at the interrupt service register (ISR) to figure out which interrupts need to be serviced. Each bit in the ISR represents an individual interrupt source. If a bit X in the ISR is ‘1’ then interrupt source X needs to be serviced. If bit X in the ISR is ‘0’ then the interrupt has not fired and does not need to be serviced. After servicing each active interrupt, the processor must then clear the interrupt as well as its source. The ordering of this operation is extremely important due to the fact that clearing an interrupt before clearing its source will result in apparent multiple interrupt events for a single source event. Therefore it is pertinent to always clear an interrupt at its source, and then proceed until you have cleared the interrupt at the PIC and at the processor. If interrupts are cleared incorrectly then “bad” situations can occur. For example: . | Interrupt0 occurs. | Bit0 in the ISR is set to 1. | . | CPU receives an interrupt and then CPU jumps into its interrupt handler routine. | CPU checks Bit0 in the ISR. | CPU then services the interrupt, but forgets to clear Bit 0!!!! | . | The CPU now returns from its interrupt handler routine to continue “normal” processing. | OH NO, BUT WAIT!!!! Bit0 has never been cleared, so the CPU’s interrupt line is still asserted!!!! . | The CPU jumps right back into the interrupt handler routine, even though no new interrupts have occurred!!!! | . | . In order to correct the situation described above, the interrupt handler should clear the interrupt at its source, and then at the PIC in step (3). Clearing an interrupt at the PIC can be done by writing a ‘1’ to the bit of interest to the PIC’s interrupt acknowledge register (IAR). ",
    "url": "/classes/embedded-systems/labs/lab5/#background",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#background"
  },"75": {
    "doc": "Lab 5",
    "title": "Project Assignment",
    "content": "Before Executing the Lab: . I recommend looking through the AXI Timer Documentation and AXI Interrupt Controller Documentation documents at their respective links to better understand the modules we will be working with in this lab. It is also worth mentioning that C documentation for interacting with these modules is available within SDK by looking at the system.mss file typically located within a project with the “_bsp” suffix. Hardware: . In lab 4, we made modifications to the block design in Vivado to enable future interrupt capability; however, there was a slight oversight in the instructions of that design. Because this is a complex lab with a lot of new C code to comprehend, I won’t make the modification of the block design a part of this lab and will supply a working bitstream file and example set of projects within a SDK workspace folder. This folder can be found here (https://github.com/zackheil/teaching-CSCE4114-EmbeddedSystems). To use the project, download the linked repository and extract the folder “lab5.sdk” to a usable space on your computer. From here, open SDK 2016.4, and when the prompt appears, choose the lab5.sdk folder to be the workspace location. This should open the SDK project with the included bitstream that supports interrupt functionality as well as a few example projects. Software: . Now, you must write software to enable the features of the newly created interrupt-based system. This involves writing initialization code that will enable interrupt-related functions on all of the interrupt sources, the interrupt controller, and the MicroBlaze processor. Additionally, an interrupt handler routine will be written to handle interrupts when they occur. Conceptually, an interrupt handler routine can be thought of as a function that can be called at anytime from anywhere (if interrupts are enabled). This implies that an interrupt handler routine must not have any effect on the state of the CPU, otherwise, program behavior could be seriously altered by the assertion of an interrupt . An Example: Consider a program controlling a stoplight puts a counter value in r20 to represent how long to keep the yellow light lit, and let us also say that a “rogue” interrupt handler routine always sets r20 to 0x0000_0000. The program would not be able to detect when this happens due to the fact that an ISR can be invoked at any time interrupts are enabled. This would essentially cause the stoplight to go from green to red instantly, which could result in adverse real-world effects. On the other hand, an interrupt handler routine is allowed to change values in memory (i.e. variables, device registers, etc.) as this does not have any side-effects on the actual state of the CPU. Thus, an interrupt handler routine must save all pertinent CPU state upon an interrupt, and must restore the CPU state after servicing needed interrupts. In the case of the MicroBlaze processor, this is handled by the “main” interrupt handler routine; which is a function that “wraps” up the user’s interrupt handler routine in such a way that the user does not have to worry about saving CPU state. This requires a programmer to “register” their interrupt handler routine so that the “main” interrupt handler knows which user-level handler to call upon invocation of an interrupt. Essentially, registration just involves putting the address of the user-level function in a place known by the “main” interrupt handler. This place is known as the interrupt vector table. Interrupts on the MicroBlaze can be enabled/disabled by interacting with the MSR register. The MSR register is a special purpose register, so the MTS and MFS instructions are needed to read/write the MSR register. The basic order of operations for your software should be the following: . | Main program: . | Setup interrupts | Register a handler | Enable interrupts on all sources. | Setup the timer to generate a periodic interrupt. | This is done by setting bits in the timer Control and Status Register . | In our case there a few hints I will give you, but the rest have to be understood and set by you . | The timer mode should be set to generate | Enable external generate signal and enable external capture should be set to 0 | For the counter to run load should be a zero, for the counter to Load a value it shouldn’t be running | Pulse width modulation should be set to a zero | . | . | . | Enable interrupts on the MicroBlaze. | Enter an infinite loop to print out a global variable, called X. | . | Interrupt handler: . | Service each interrupt that has fired. | Do this by incrementing the global variable X. | Clear and service all interrupts that have fired. | Clear them at the source, then the PIC. | Return | . | . It’s worth noting that all of these steps are required to get interrupts working from the ground up, but some of the functions provided by Xilinx that we will be using actually perform these operations behind the scenes. As you look through some of the examples in the provided SDK project, feel free to explore the source code of the provided functions by right clicking on functions, variables, or definitions and selecting “Open Declaration” to see where these calls are actually made. ",
    "url": "/classes/embedded-systems/labs/lab5/#project-assignment",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#project-assignment"
  },"76": {
    "doc": "Lab 5",
    "title": "Project Instructions",
    "content": ". | Start off by downloading and extracting the lab5.sdk folder from the Github link above. | Open SDK and set the workspace to the extracted folder to get access to the example projects and the bitstream. | From here, load the bitstream on to the Arty board. Before moving on to timer interrupts, let’s look how we can trigger an interrupt using software with a provided example. | Open up the project “xintc_low_level_example_1” from the project explorer pane and locate the C file in the src directory. Look through the code and inspect what it will be doing before attempting to run it. | Open up a serial terminal monitor to the correct COM port like in earlier labs. | In the Project explorer, highlight the current project’s root folder (has “xintc_low_level_example_1” in it) and then click on the debug icon dropdown in the toolbar beside the usual run button that is pressed to execute code on the Arty. Choose “debug as” and “run on system hardware”. The code will stop as soon as it enters the main function. | Step through the code to see what each step is doing and how it operates. At some point in execution, you will see a function call to XIntc_SimulateIntr which will set the ISR register and will seemingly reroute the execution to the DeviceDriverHandler function at the bottom. | This function will write to the console that an interrupt has occurred and then will resume execution where it left off. | . | Now that we have seen an example of how the ISR can be set with the simulate interrupt function that Xilinx has, let’s now use the timer to trigger the interrupt. Open up the “timer_interrupt_example_zheil” project. This demonstrates a useful example where the Microblaze is just trying to execute a while loop where it outputs a counter value to the LEDs, yet is constantly interrupted to update the counter that the LED is outputting. | Observe the extra steps to set up the timer interrupt and the options that were previously set using direct register setting operations with pointers. | Also observe how the functions for setting up both the interrupt controller and the timer were extracted into the main function in a linear format so that the instructions could be seen without the need to jump into the function calls. In your implementation of the timer interrupts, take these operations and group them into meaningful function calls so your code isn’t as linear as this demonstration. | Highlight the project root in the project explorer and run this example. Note that it is a simple binary counter that increments every half second. | Take some time to really understand this code, then create a new project and add the FSM design, but modify the design to use the interrupts instead of relying on polling. Remember that there are stricter grading guidelines for this lab, so be mindful of the timing for each state. | . ",
    "url": "/classes/embedded-systems/labs/lab5/#project-instructions",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#project-instructions"
  },"77": {
    "doc": "Lab 5",
    "title": "Pre-Lab Questions",
    "content": ". | Instead of pre-lab questions this week, I encourage you to please read through this entire lab assignment once and go through the example (commented) programs supplied in the lab5.sdk project. | . ",
    "url": "/classes/embedded-systems/labs/lab5/#pre-lab-questions",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#pre-lab-questions"
  },"78": {
    "doc": "Lab 5",
    "title": "References",
    "content": ". | AXI Timer Documentation (https://www.xilinx.com/support/documentation/ip_documentation/axi_timer/v2_0/pg079-axi-timer.pdf) | AXI Interrupt Controller Documentation (https://www.xilinx.com/support/documentation/ip_documentation/axi_intc/v4_1/pg099-axi-intc.pdf) | File:Xps timer.pdf - XPS Timer documentation | File:Edk interrupts.pdf - Step-by-step instructions on how to create interrupt-based systems (old version but go for it if you’d like) | . ",
    "url": "/classes/embedded-systems/labs/lab5/#references",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/#references"
  },"79": {
    "doc": "Lab 5",
    "title": "Lab 5",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab5/",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/"
  },"80": {
    "doc": "Lab 4",
    "title": "Lab 4: Timers",
    "content": "In this lab we will replace the dummy loops inserted in the previous lab to waste a certain amount of time for transitioning the traffic lights with more precise delays provided by the Xilinx AXI Timer core. The timer core contains two 32 bit timers that can be used independently or combined to form either (1) an extended 64 bit timer, or (2) as a Pulse Modulation Wave generator. When used independently each timer can be set up in either (1) Capture, or (2) Generate Mode. There are many different solutions you could implement for this lab using a combination of the two timers. However the simplest solution is to use one timer in the Generate Mode. Before you enter the lab you should read and familiarize yourself with the Timer Core Datasheet. Specifically you should study the data sheet to determine: . | How to set the control register to configure the timer to be in the generate mode, count down, automatically reload, and disable the generation of an external interrupt. | How to set the control register to transfer the value from the load register into the timer and then start the timer. | How to poll the status register to identify when the counter transitions down to 0 (i.e 3..2..1..0…reload new count from load register). Hint: You will have to poll a bit (read) and then once the transition is identified, clear the same bit by writing back a 1. | . ",
    "url": "/classes/embedded-systems/labs/lab4/#lab-4-timers",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/#lab-4-timers"
  },"81": {
    "doc": "Lab 4",
    "title": "Project Assignment",
    "content": "What follows next is a description of how to use a single timer in the Generate Mode to provide all timing for the Fayetteville Bike crossing. Here is a strategy: . | Create a delay word to write into the load register to have the timer go off every .5 seconds. | When you enter the green light state, turn off the timer | When you enter the first flashing red state turn on the timer. You can use the timer going off every .5 seconds as your signal to alternate the red LED (flashing red light changes every .5 seconds). You will have to check for an additional button push which resets the sequence for another 6 seconds from the button push | In the solid red state the red light signal will remain on for six seconds. You can time this state by counting the number of .5 second timer events. | When you enter the second flashing red sequence the timer will be on and you can use the timer to once again alternate the flashing of the light every .5 seconds. | . ",
    "url": "/classes/embedded-systems/labs/lab4/#project-assignment",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/#project-assignment"
  },"82": {
    "doc": "Lab 4",
    "title": "Project Directions",
    "content": "To start off, we need to add the AXI Timer module to our SoC. This means we need to go back into Vivado and make some modifications to our block design. If you have kept your project organized such that you can modify your original design, then go ahead. If not, you can use the base-soc project that was given back in Lab 2 from here (https://github.com/zackheil/base-soc). It has instructions on how to get started with rebuilding the project from a set of TCL scripts. Note: if you have used this repository/project before, you might have an issue when opening Vivado and running the TCL script with an error saying the directory already exists. This is because the TCL script project is created in the AppData directory in Windows and not a set location like your Desktop or Documents folder. To get rid of this error, you can go to the Windows Start menu, type in %appdata% in the search bar and press enter. A directory called “Roaming” will open. From there, navigate to Xilinx\\Vivado\\ to see your temporary projects directory. Take the existing base-soc folder and rename it (e.g.: base-soc-OLD). Now you should be able to open Vivado and run the TCL script again. Now that we have our Vivado project open, we need to go into the block design. Once in the block design, perform the following steps: . | On the left side of the block design diagram, there is a mini toolbar with quick actions. Click the “Add IP” button and search for the AXI Timer. Double click on it to add it to the block design. | Run the automator from the blue pane that appears at the top. When choosing a clock source to connect to the timer, select the 83.3MHz “mig_7” source. | Now, to future-proof the design with interrupt capability, let’s add another IP block. Add the “AXI Interrupt Controller” to the design in the same fashion as the timer. Run the automation that appears in the banner. | Now we need to manually connect certain I/O to respective ports to create functionality: . | Connect the interrupt output on the left side of “AXI Interrupt Controller” to the “Interrupt” input on the right side of the MicroBlaze block. | Connect the interrupt output on the AXI Timer block to the intr[0:0] input on the AXI Interrupt Controller. | . | Regenerate the layout and take a screenshot of your design. If you need help later on in the lab, I will need to see this layout to ensure you connected everything correctly. | Now, just like Lab 1, validate the design, generate the HDL wrapper, and create the bitstream. | Export the bitstream and launch SDK from the respective File menu options | . Note: if you do not choose to complete the lab in one sitting, and have your project stored in the AppData directory from the TCL loading process, remember that is where your project is currently stored when you return to work on the lab later. Now, within SDK, create a new blank Application project for Lab 4. You are eventually going to transfer your FSM design of our bike-crossing light over and use the timer instead of the delay function previously created. Before you do this though, take some time to play around with the Timer module in C code either using the Xilinx API by including “xtmrctr.h” as a header file, or by using pointers like how you interface with GPIOs currently. The implementation choice is up to you. If you would like to use the “xtmrctr.h” APIs, you can open up the system.mss file included with your project and it will show the peripherals you currently have installed and C examples for how to interface with them with Xilinx APIs. Because this method of controlling the timer is vastly different than using pointers, I will only be able to aid in debugging with the pointer implementations. So if you do not make headway with the API or don’t know where to start, choose the pointer method. The base implementation of the pointer method is detailed below: . | Locate the addresses for the necessary timer registers detailed in the data sheet in the same way you located the LED and switch registers from the previous labs. | Create a simple C program that implements an LED register set. I recommend the 4 green LEDs just for simplicity. The goal with this mini project is get the timer to function in 1 second intervals to ensure you have everything working before trying to add timers to your existing code base and getting confused. | Before adding any timer code, ensure you can blink an LED or implement a binary counter timer, like the example below: | . | . void main(void) { // setup LED direction and variables... int count = 0; while(1) { count++; *ledDataReg = count; // reset the binary counter when it reaches 15. if(count &gt;= 0xF) { count = 0; } } } . | You will notice if trying to run the above code that all LEDs will just look like they are lit and not counting at all. This is because the while loop is going super fast. So we can temporarily slow this down with an empty for loop somewhere in the while loop that looks like this: for (int i = 0; i &lt; 5000; i++);. You should be able to see the individual LEDs blink now | Now let’s setup the timer before that while loop. You should have read the data sheet on the particular registers, so it should be a simple task to set the necessary bits in the following registers: . | For this sample code, we want the LEDs to count up every second. So we want the timer to count down from a certain value and when it hits 0, it will raise a flag. So, given the timer runs off the 83.33MHz clock, counting down from 83.33 million will take exactly one second to do. Set TLR0 to 83.33 million. | For TCSR0, we want to set a combination of bits in a certain order. First, set the mode to generate, set the timer to count down, we want to auto-reload the timer, and we want to load the TLR0 into the timer register. All of this can be set at once using a binary or hex number value, like this (values are not correct): *TCSR0 = 0b1001001010. | Now to enable the timer, the data sheet says that if we load a value into the register (set bit 5 TCSR0), we need to clear that bit while enabling the timer, else the timer will not start. So again, set the TCSR0 register, but clear bit 5 while also setting the enable timer bit. The timer will now count down from 83.33 million and will raise a flag on TCSR0 (bit 8) when it hits 0. | Finally, to use this in action, we need to detect when that flag is set in our loop and take appropriate action to clear the flag so we can detect when the next count down hits 0. Remove the for(…) loop that was created above to slow down the while loop. This for loop and our previously created delay_ms() function stalls the processor so it has to take a considerable amount of time processing pointless instructions when it could be executing other code in the while loop. Instead, we want to make the while loop as fast as possible and not stall it with a wait and instead just poll the timer and see when it completes and take action to reset it. Instead, in the place of the for loop, create an if statement that can detect the complete flag bit of the timer. Something like this would work: if((*TCSR0 &amp; 0b00100000000) == 0b00100000000). Now if and only if we have a timer that counted down zero, we want to increment our count, so move the count++ into this if statement. | If you were to run this code at this point, it would not work. This is because you need to clear this flag bit once you discover it is set, else you would just read the flag with every following loop. To clear the bit, the data sheet says to set the bit to 1 (yes, it already is a 1 when you read it, but they made it reset when you write a 1 to it). Add this set bit operation to the if statement. | Run the code and observe how it counts up to 15 with each step taking one second | . | Now that you know how to interface with the timer, implement the above behavior using your FSM from last week. Replace the stalling delay_ms function with appropriate function calls that turn on, off, and read the timer complete flag | . Ask for clarification if you have any questions . ",
    "url": "/classes/embedded-systems/labs/lab4/#project-directions",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/#project-directions"
  },"83": {
    "doc": "Lab 4",
    "title": "Pre-Lab Questions",
    "content": "Your answers should be typed and printed with your name, date and lab number. In addition to answering the following questions, please read the lab assignment on this page and reread Xilinx AXI Timer Datasheet. You may want to write pseudo code if you think you may have trouble finishing the project during your lab time or if you’re feeling like a good student. | What is the advantage of a timer over the previously used delay_ms function? | There are several registers required to interface with the timer module in the SoC, what are those registers and what is their function? | When enabling the timer, there is one bit you need to set and one bit you need to clear. What are those two bits? | What two methods exist in C for setting the timer parameters? | . ",
    "url": "/classes/embedded-systems/labs/lab4/#pre-lab-questions",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/#pre-lab-questions"
  },"84": {
    "doc": "Lab 4",
    "title": "References",
    "content": ". | Xilinx AXI Timer core | . ",
    "url": "/classes/embedded-systems/labs/lab4/#references",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/#references"
  },"85": {
    "doc": "Lab 4",
    "title": "Lab 4",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab4/",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/"
  },"86": {
    "doc": "Lab 6",
    "title": "Lab 6: Autonomus Vehicle",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab6/#lab-6-autonomus-vehicle",
    
    "relUrl": "/classes/embedded-systems/labs/lab6/#lab-6-autonomus-vehicle"
  },"87": {
    "doc": "Lab 6",
    "title": "Week 1",
    "content": "Introduction . This first week is devoted to assembling and testing your autonomous robot car. First you and your partner will modify your SoC to include the peripherals necessary for communication with the car sensors. Then you will follow the video instructions to assemble the shadow chassis, which is the base platform for your Arty Bot. Your TA help you through the assembly process. Zip ties and colorful “engineering” rubber bands will be able in the lab if you need them . Lab Instructions . | Go to Digilent’s IP (Intellectual Property) repository on GitHub and download their repository of hardware sensor IP and interface definitions. Extract the downloaded zip file and remember the location on your computer where you extracted the files. Ideally, put the extracted folder next to your project folder. | Next, download this GitHub repository and extract it to a separate folder. This repository contains IP necessary for interfacing with the Pmod DHB1 and MAXSONAR hardware sensors. | Now let us make some changes to our SoC (System on Chip). Start by opening your project in Vivado. Navigate in the Flow Navigator on the left side to “Open Block Design.” | To add our downloaded IP to Vivado, navigate to “Project Settings” to open the project Settings dialog. In the left panel select “IP,” then select the “Repository Manager” tab. Now add the two IP repository folders you downloaded. Select “Apply” and close the dialog. | Back in the block design of your SoC. We want to add IP to the SoC for communicating with the external Pmod peripherals. We will add “AXI GPIO,” “Pmod_DHB1”, and “Pmod_Dual_MAXSONAR” IP for communication with the two line detecting light sensors, Pmod MAXSONAR sensor, and Pmod DHB1 motor driver . | AXI GPIO » jA - Pmod LS1. Using the “Add IP” button and dialog. Add a new “AXI GPIO” and “Pmod Bridge” IP to your design. DO NOT USE connection automation. Connect the “S_AXI” bus port of the “AXI GPIO” to a slave port on the interconnect. Link to the two GPIO ports on the “AXI GPIO” with the “GPIO_Top_Row” and “GPIO_Bottom_Row” on the Pmod Bridge. Last, in the “Board” window on the left, right-click the “jA” port under Pmod and select “connect component.” In the dialog that appears, find the Pmod bridge you just added and select the “Pmod_out” port as your connection. One more thing, enable interrupts for the “AXI GPIO.” | Pmod_Dual_MAXSONAR » jB - Pmod MAXSONAR. Add the “Pmod_Dual_MAXSONAR” IP and connect it to a Pmod Bridge. You can connect the “Pmod_out” port of the Pmod Bridge to the Pmod port jB. | Pmod_DHB1 » jD – Pmod MAXSONAR. Add the “Pmod_DHB1_v1_0” IP and connect it to the jD Pmod port through a Pmod Bridge | . | Go to “Address Editor” window of the block design and and assign memory addresses to the newly added IP. | Validate your deign and generate a bitstream | Watch the assembly instruction video or follow the instructions given here to assembly the chassis of your robot. | . Assignment Instructions . | Mount the two IR (infrared) Proximity sensors somewhere on the front of car. Try to mount them as close as possible to the floor. Connect the sensors to one of S1, S2, S3, or S4 pin headers on the Pmod LS1 module. Finally, connect the Pmod LS1 module to the Arty board via the Pmod port you connected the AXI GPIO in the board design. | Mount the two Pmod MAXSONAR sensors on the front of the car. Use the provided Pmod extension cables to connect the sensors to the Pmod port where you connected the AXI GPIO in the board design. Connect one sensor to the bottom row of the Pmod port and the other to the top row of the same Pmod port. | Connect the Pmod DHB1 to the Arty board via the Pmod port you selected in the board design. Now make the following connections on the Pmod DHB1 module: . | Connect the left and right motors to the screw terminals J5 and J6. | Connect the Hall effect sensors to J7 and J8. The red wire is VCC, black is GND, and white is motor feedback. The motor feedback signal is used to count wheel revolutions using the Hall effect sensors. | Connect the AA battery pack to the screw terminal at J4. | . | . Pre-Lab . Take a look at the manuals listed in the references sections . | Tang, A. ArtyBot - A two-wheel robotics platform built on the Arty development board. Hackster.io | Pmod Interface Specification | Pmod LS1 Reference Manual | Pmod MAXSONAR Reference Manual | Pmod DHB1 Reference Manual | . ",
    "url": "/classes/embedded-systems/labs/lab6/#week-1",
    
    "relUrl": "/classes/embedded-systems/labs/lab6/#week-1"
  },"88": {
    "doc": "Lab 6",
    "title": "Week 2",
    "content": "When determining which scheduling solution your embedded system should use, there are a variety of options that range from a simplistic bare-metal design, like we used in lab 6, to a full embedded Linux distribution (called PetaLinux). Choosing one may come down to factors like: . | Responsiveness and compatibility: Companies like TI or Xilinx may create their own RTOS (e.g.: TI-RTOS or XilKernel) that work the best on the hardware they tailor it for. Some also follow POSIX standards such that maximum compatibility exists for programming between different devices (e.g.: You can create pthreads on your computer, as well as TI-RTOS and XilKernel as they are POSIX compliant, but not the standard FreeRTOS). | System resources: Larger embedded systems may have multi-core systems that support embedded Linux or a combination of systems (PetaLinux + FreeRTOS). | Licensing: Certain software packages like Azure RTOS and others commercially available for cloud IoT uses require licensing. | . For this lab, we will be using FreeRTOS to convert our bare-metal task switcher into a full RTOS-driven system that supports preemption and has a programming feel that is closer to that of programming multi-threaded programs for computers. FreeRTOS has been described as “the de facto standard” and “market leading” because of its robustness, the wide range of microprocessors supported, and lack of a license needed to use it. Xilinx has deprecated the use of their “XilKernel” system and have since removed it in versions of SDK &gt; 2016. FreeRTOS provides a small, robust, and modular kernel. It is highly integrated with the Xilinx SDK and is a free software library option that can be selected when creating a new project. It allows a very high degree of customization, letting users tailor the kernel to an optimal level both in terms of size and functionality with most modifications readily available in the “FreeRTOS.h” and “FreeRTOSConfig.h” header files. It supports the core features required in a lightweight embedded kernel, however, the version included with the Xilinx 2016.4 SDK is not POSIX compliant and does not support pthreads. FreeRTOS can be used to implement higher level services (such as networking, video, and audio) and subsequently run applications using these services. For this lab, we will be using the same SDK workspace folder provided for labs 5 and 6 to create the FreeRTOS project and migrate our traffic signal from the bare-metal design. If you need to download a fresh copy of the workspace, it can be found here. Project Directions . | Start off by downloading this repository, which has a few examples for working with your car. | Open your workspace from previous labs and go to File &gt; New &gt; Application Project. If for some reason you do not have a workspace, use the examples workspace in the cloned repo. | When the “New Project” preferences window appears, name the project “lab7” and in the “OS Platform” selection, choose freertos823_xilinx. (Note: if you are using a different version of SDK, your version of FreeRTOS may vary). Click next and choose the empty project option, then click finish. | Copy the files (artyBotLib.h, artyBotLib.c, motorControl.h, motorControl.c, pidController.h, pidController.c) from the ArtyBot_example0/src example directory and paste them into your newly created project’s src directory. | With the newly created project, right click on the src folder and create a new file (New &gt; File). Name the file “main.c” and paste the following contents in it as a starting point: | . /* FreeRTOS includes. */ #include \"FreeRTOS.h\" #include \"task.h\" #include \"semphr.h\" /* Xilinx includes. */ #include \"xil_printf.h\" #include \"xparameters.h\" #include \"xgpio.h\" #include \"xintc.h\" /* Other includes */ #include \"artyBotLib.h\" #include \"PmodMAXSONAR.h\" // Car states typedef enum {IDLE, DRIVE, NAVIGATE} State; State state = IDLE; // Shared resource. Mutex driven. SemaphoreHandle_t state_mutex; /* FreeRTOS Tasks */ // ... /* Main Function */ int main(void) { // Setup and init code // Start FreeRTOS Kernel return 0; } . | We will attempt to develop our car with a structure similar to the traffic signal from previous labs. Let’s attempt to first migrate part of the “task chooser” thread that was used in in the previous lab to govern when the other tasks were supposed to run. | To create a thread in FreeRTOS, we first need to create a task handle struct that the kernel will use to associate a task with. Above main(), create a handle called SupervisorTaskHandle and initialize it to null, like so: TaskHandle_t SupervisorTaskHandle = NULL; | Next, we need to create a task handler function that will execute. Similar to last lab, create a function that will act as a thread runner that takes in a void pointer parameter, like: void SupervisorTask(void *arg) {...}. Fill out the contents of this function with just an infinite loop. | Now we are going to formally create the task with xCreateTask. That macro has the following parameters: xCreateTask(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask). These parameters are explained by hovering over the macro name, right-clicking, and opening the declaration (or F3). I’ve also provided the parameter details below: . | pvTaskCode Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop). | pcName A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN - default is 16. e.g.: “Supervisor” | usStackDepth The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. | pvParameters Pointer that will be used as the parameter for the task being created. | uxPriority The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to ( 2 | portPRIVILEGE_BIT ). | pvCreatedTask Used to pass back a handle by which the created task can be referenced | . | So our xTaskCreate will look like: xTaskCreate(SupervisorTask, \"Supervisor\", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;SupervisorTaskHandle); Notice how we are just passing NULL for the parameter and that we are passing the address of the TaskHandle type. If you pass the value directly, your tasks won’t be able to suspend/resume if you attempt to use the functions. | Now we must acknowledge an issue before moving forward. We plan on having several tasks being able to write to the state variable when that thread has deemed the condition should move to the next state. E.g.: the IDLE task will set the state to DRIVE, the STOP task will set the state to IDLE and so on. The issue arises when we have multiple threads with the ability to write a variable and a thread trying to read the variable in our preemptive system. We are going to need to implement a mutex around our state variable to ensure that it is written to by one thread at a time. | Go back up to the top of the file where the state variable is globally defined and add the following line below it: SemaphoreHandle_t state_mutex; Then back in the main function, we can setup the mutex with the line: state_mutex = xSemaphoreCreateMutex(); | With this mutex, we can now try and acquire the lock with xSemaphoreTake(state_mutex, TRY_TICKS) and we can unlock with xSemaphoreGive(state_mutex). Notice TRY_TICKS in the semaphore take function. It represents the number of RTOS ticks (time unit, by default set to 100 ticks/sec) that the system will try to acquire the lock within, if it can’t within the number provided, it will just fail. | Now in our SupervisorTask function infinite loop, we can see if the mutex is locked or unlocked using the return value of a function in an if statement: | Now we can prime which thread needs to run in our Supervisor Task similar to how we did in in the previous lab with the ready flag being set to true/false. vTaskSuspend(/* TaskHandle_t type */) will suspend a task from the scheduler and vTaskResume(/* TaskHandle_t type */) will add a task back to the pool of tasks to execute. You can add these function calls to the switch statement cases above to set which thread will execute after running the supervisor. | At the end of this block of code when we can make the thread go to sleep for a set amount of time. vTaskDelay(/* num of ticks */) will let the task sleep for a certain number of ticks. Notice this is not seconds, as 1 tick = 1/100 second. There is a simple macro to convert ticks to seconds and can be used as a parameter in the vTaskDelay function to sleep for a certain number of milliseconds: vTaskDelay( pdMS_TO_TICKS(/* ms to sleep */) ). | Side note: if you are trying to make an LED flash or stay lit for a certain period of time, the vTaskDelay call in that particular task function should make that task trivial. | . | . | . while(1) { // Acquire mutex lock if( xSemaphoreTake(state_mutex, 10) ) { // We have access to the mutex. // Do critical operations here switch(state) {/* ... */} // Release lock xSemaphoreGive(state_mutex); } // Sleep for a small amount of time // ... } . | To start the kernel, add the line vTaskStartScheduler(); right before the return statement in the main function. | Now that we have gone through the basis of recreating the task choose thread from the previous lab, go ahead a create some tasks that correspond to driving your car. You should have all the function calls you need. | The example project ArtyBot_example0 has some examples of what your states can look like. That being sad, there are many different ways to get this project done. Add extra states if you need them. | . Assignment . | Turn your car into a line following robot. The line will be a (white) duct tape track and your car should drive around the track with wheels on either side of the track. There will be an obstacle at the end of the track, use this to stop your car. To do this, you will need: . | Use the GPIO PMOD LS1 to detect when your car drives over the line and steer that car back onto the track | Use the PMOD MAXSONAR to detect obstacles and stop the car before the obstacle. | Program the Arty’s non-volatile 16 MB Quad-SPI flash memory with your SoC and application so that your application runs when you power on the Arty board. NB: the file names in this section may be different from what you have in your project. Just remember what you named your soc in Vivado and project name in the SDK and the rest should look familiar. If you’re unsure ask your TA for help. To program your Arty . | Right click your project folder, the project you want to flash onto the board, and select Generate Linker Script. On the right side, change all 3 dropdowns from microblaze_0_local… to mig_7series_0_memaddr. If you are on Linux this might not work. You may need to open the lscript.ld file in your project’s src directory and manually change all the entries to mig_7series_0_memaddr. | Click the Program Flash button in the toolbar. Next to Image File, click Browse and navigate to your project folder, then into Debug. Select your_project_name.elf and click open. Next to Offset, enter 0x00C00000. This is the address offset where your program will be stored in the flash memory. Next to ‘Flash Type,’ select S25FL128sxxxxxx0-spi-x1_x2_x4. IMPORTANT, make sure ‘Convert ELF to bootloadable SREC format and program’ is checked. Click Program. | To create a bootloader, in the toolbar select File &gt; New &gt; Application Project. Name the project something like ‘bootloader’ as shown in the image above. Click Next. | Select SREC SPI Bootloader, and select Finish. | We need to make a few changes to our bootloader before loading it onto the Arty board. First, we need to set the ‘address offset’ so the bootloader can find our application. In the ‘Bootloader’ project, open the blconfig.h file and change the FLASH_IMAGE_BASEADDR to 0x00C00000. Note, this same address you used when you flashed your application onto the flash memory earlier. | Optional, if you wish to improve your ArtyBot’s startup time. Edit the file bootloader.c and comment out the line #define VERBOSE. This will turn off console logging. NB: Console logs may be useful when you’re initially setting things up. | Click the Program FPGA button in the toolbar. In the right half of the Software Configuration section, there is a cell that says bootloop. Click the right side of this cell to reveal a drop-down menu. Select Bootloop.elf from the list, then click Program. This will generate a bit file with the MicroBlaze’s memory initialized with the program that you have written. The Arty is also programmed and if everything went well you should see your application running in your favorite console application (e.g. Putty or TeraTerm) | Almost there, click the Program Flash button in the toolbar. Next to Image File, click Browse and navigate to the SDK workspace, then into base_soc_wrapper_hw_platform_0. Select download.bit and click Open. Next of Offset, enter 0x0. Next to Flash Type, select S25FL128sxxxxxx0-spi-x1_x2_x4. Click Program. | Congratulations, you have flashed the bootloader and your application to the non-volatile SPI Qflash memory. Next time you power on the board, the bootloader will be copied from the flash memory and when it runs, it will execute your application. | . | . | . Pre-Lab Questions . None this week. Lucky you! . References . | FreeRTOS Manual https://www.freertos.org/FreeRTOS-quick-start-guide.html (expand API Reference on the side for full documentation on function calls) | . ",
    "url": "/classes/embedded-systems/labs/lab6/#week-2",
    
    "relUrl": "/classes/embedded-systems/labs/lab6/#week-2"
  },"89": {
    "doc": "Lab 6",
    "title": "Lab 6",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab6/",
    
    "relUrl": "/classes/embedded-systems/labs/lab6/"
  },"90": {
    "doc": "Lab 3",
    "title": "Lab 3: Fayetteville Bike Crossing",
    "content": "In this lab you will use your Arty-7 board and knowledge of push buttons and LEDs from the previous lab to create a controller for Fayetteville’s bike/waking paths. The bike/walking path crosses streets where cyclists/walkers have a control box they can use to control the traffic lights for cars . Cyclist/Walker control Boxes: One on each side of the path that crosses the road. Cyclists/Walkers push the button in the box to request a crossing and control the traffic lights. Traffic Lights: . | Solid Green: Cars are free to travel through the crossing at speed. This signifies no cyclists/walkers have requested a crossing. | Solid Red: Cars must stop. This signifies a cyclist/walker is in the crosswalk. | Blinking Red: Cars must slow and look for cyclists/walkers. A blinking red occurs prior to and immediately following a solid red light. | . Operation and control of the push button control box: When a cyclist/walker pushes the button in the control box: . | If the traffic lights are green they immediately start flashing red for 6 seconds | If the traffic lights are already flashing red the new button push will flash for an additional 6 seconds from the time of the new button push. | If the traffic lights are solid red, the button push will have no effect and the solid red will display for 4 seconds from the first button push. | . So the states in order go: green → blinking red → solid red → blinking red → green. In general, any of the push buttons should activate the crosswalk logic, but all 4 RGB LEDs should be used for the status for the cars. ",
    "url": "/classes/embedded-systems/labs/lab3/#lab-3-fayetteville-bike-crossing",
    
    "relUrl": "/classes/embedded-systems/labs/lab3/#lab-3-fayetteville-bike-crossing"
  },"91": {
    "doc": "Lab 3",
    "title": "Lab Directions",
    "content": "This is a two part lab that will run in two weeks. In the first week you will have to simulate the 4 and 6-second delays using dummy loops. In the second week you will replace the dummy loops with a timer. | Week 1. In the first week you will write the code to control two push buttons signifying the two cyclist/walkers control boxes and two LEDs signifying the traffic lights. After a control box is pushed, the traffic lights automatically transition between blinking red, solid red, blinking red, and then back to green. You will need to simulate this transition using delay loops. Ie., after a button is pushed the blinking red should appear for approximately 6 seconds, then switch to solid red for 4 seconds, back to blinking red for 6 seconds, and then back to green. Since you don’t have timers you will have to write nested loops that essentially do nothing useful but delay for the appropriate amount of time (approximately, can be a little fast or slow) before switching to the next color. | . You will also have to blink the red LED on and off at approximately 1 second intervals to simulate the flashing red. Step 1: . In SDK, create a new blank Application project using the base-soc.sdk workspace like in last lab. Create a lab3.c file and populate it with the necessary empty main() function and includes. | To start off, we can see this lab is going to utilize waiting in varying time intervals based around the second unit. It would probably be helpful if we created a function to wait for us. Let’s make a delay_ms(int ms) function, so we can reuse it in other portions of this lab and possible future labs: . | Copy/paste the following to your source code file: | . | . void delay_ms(int ms) { for(int i = 0; i &lt; 134 * ms; i++) { asm(\"nop\"); } } . You may need to tweak the loop so that it approximates a second when delay_ms(1000) is called. Now that you have a working delay function, you can delay for one second by calling delay_ms(1000); in your main function. Create a while(1) section in your main function and create the desired functionality described above using what you have learned from last lab. It would be helpful to break the individual sub-routines down into functions for organization and modularity. Step 2: . You will factor your code into a Finite State Machine model for creating state transitions. You should be familiar with FSM models from Digital Design and System Synthesis. At a high level, an FSM is an abstract machine or mathematical model that describes the transitions from a current state and set of inputs to a next state with a set of outputs. FSMs are very convenient for modeling and implementing the behaviors of embedded and real time systems as a series of transitions that result from the presence of external inputs (sensors, buttons) that result in the setting of external outputs (actuators, relays etc). You should have some experience from Digital Design and System Synthesis in writing Moore and Mealy FSMs in Verilog or VHDL. We can model an FSM in C using the switch(), case 1, case 2… constructs. Below is a skeleton template (not complete) of an FSM for the Fayetteville bike crossing. typedef enum {RED, GREEN, FLASH_RED_START, FLASH_RED_END} State; // Create state variables State state, next_state; // Basic template for FSM model void FSM_tick() { switch(state) { case RED: // code for RED state &amp; logic for next_state next_state = ?; // next state after RED break; case GREEN: // code for GREEN state &amp; logic for next_state next_state = ?; // next state after GREEN break; case FLASH_RED_START: // code for FLASH_RED_START state &amp; logic for next_state next_state = ?; // next state after RED_START break; case FLASH_RED_END: // code for FLASH_RED_END state &amp; logic for next_state next_state = ?; // next state after FLASH_RED_END break; } state = next_state; // update next state } int main() { // initialize crossing to a state from the enum state = ?; // keep on loopin' while(1) { // cycle through traffic light pattern FSM_tick(); } return 0; } . ",
    "url": "/classes/embedded-systems/labs/lab3/#lab-directions",
    
    "relUrl": "/classes/embedded-systems/labs/lab3/#lab-directions"
  },"92": {
    "doc": "Lab 3",
    "title": "Submission",
    "content": "Nothing will be due for the first week, though you should double-check your design and ensure it produces the desired output. Make sure your design is modular as well as we will refactor this code and use timers in place of the dummy delay loops in the second week. For the submission after week 2, you will turn in your report which should contain a state transition graph of your FSM, and your C file in a zip archive. ",
    "url": "/classes/embedded-systems/labs/lab3/#submission",
    
    "relUrl": "/classes/embedded-systems/labs/lab3/#submission"
  },"93": {
    "doc": "Lab 3",
    "title": "Lab 3",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab3/",
    
    "relUrl": "/classes/embedded-systems/labs/lab3/"
  },"94": {
    "doc": "Lab 1",
    "title": "Lab 1: Building A Basic SoC",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab1/#lab-1-building-a-basic-soc",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#lab-1-building-a-basic-soc"
  },"95": {
    "doc": "Lab 1",
    "title": "Description",
    "content": "In laboratory 1 you will complete a provided boilerplate design of a System-on-Chip (SoC) using the Xilinx-Vivado development suite and targeted at the Arty-A7-35 development board. Your design will contain a MicroBlaze soft processor, a USB UART serial controller, and a DDR memory controller that interfaces with components on the Arty board. The processor will be connected to the serial port and DDR memory peripherals in a shared-bus architecture. You will then program this SoC using the C programming language to print out your name and student ID five times to the screen of a desktop computer which is connected to the Arty-7 development board using the USB serial port. There will be 2 screenshot requirements for your report, so ensure you read the following instructions carefully. ",
    "url": "/classes/embedded-systems/labs/lab1/#description",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#description"
  },"96": {
    "doc": "Lab 1",
    "title": "Project Assignment",
    "content": "Use the provided base project to create a basic system-on-chip and add a UART serial controller to your SoC. Synthesize your system-on-chip, compile your software project, combine them into a bitstream, and download it onto the Arty-A7-35 development board. Create a software project and make it print out your name five times. This may not seem like much, but at the end of this laboratory, you will have created a system-on-chip and executed a program on top of it in a bare metal environment. This represents a rudimentary but fully functional embedded system. ",
    "url": "/classes/embedded-systems/labs/lab1/#project-assignment",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#project-assignment"
  },"97": {
    "doc": "Lab 1",
    "title": "Directions",
    "content": "Preamble - Adding Arty board to Vivado: . Before opening Vivado, visit Digilent’s website and follow the instructions listed under “Install Digilent’s Board Files”. The instructions will provide you with a download link for the board files. When you extract the archive, you only need to install the “arty-a7-35” directory, other boards are not necessary for our purposes. Vivado - Generating a bitstream: . | Start by downloading the base SoC project from GitHub. | NB: Windows users - Extract the downloaded files to a directory close to your system root directory. E.g. C:\\Users\\[username]\\Desktop\\eecs-4114-labs. Visit this page for Windows path character limit details. | . | Open the downloaded project in Vivado 2019.1. | Option 1: In the project folder (e.g. C:\\Users\\[username]\\Desktop\\eecs-4114-labs\\base-soc), double-click the file base-soc.xpr | Option 2: Start by opening Vivado 2019.1. On the welcome screen, select “Open Project”. Use the dialog to navigate to your project directory, and open the base-soc.xpr file. | . | In the left panel, “Flow Navigator”, select the “Open Block Design” option. If you are prompted. | Add the AXI UARTlite soft-ip core to the design. | Right-click anywhere in the board design window and select “+ Add IP…”. | Enter “Uartlite” in the search window and double-click on the “AXI Uartlite” option. The AXI Uartlite soft-ip core should appear in the block design along with a green bar at the top of the window. | In the green bar, select “Run Connection Automation”. Then, in the “Run Connection Automation” window, check the “UART” checkbox under “axi_uartlite..” and click “OK”. Important: leave the S_AXI box unchecked. | Almost there… Right-click the S_AXI port on the AXI Uartlite core and select “Make Connection…”. In the “Make Connection” window, select the M00_AXI under microblaze_0_axi_periph and click “OK” to make the connection. | Finally, select “Run Connection Automation” again. Select s_axi_clk under axi_uartlite.. and change the “Clock Source:” option to /mig_7series_0/ui_clk (81 MHz). Click “OK” to automate the connection of the clock and reset ports. | You may need to assign an address to the AXI Uartlite soft-ip. Open the “Address Editor” window and verify that an address has been assigned to “axi_uartlite..”. If not, right-click on “axi_uartlite..” and select “Auto Assign Address”. | . | In the “Sources” window, right-click on the “base_soc.bd” file and select “Create HDL Wrapper…”. The “base_soc.bd” file should now be nested inside “base_soc_wrapper.v” file. | Back in the “Flow Navigator” window, select “Generate Bitstream” to synthesize your design. This may take a while… | After generating a bitstream, select “File &gt; Export &gt; Export Hardware” in the top menu. Then in the export window, select the “Include bitstream” option before exporting your design. | . SDK - Creating Software Project: . | To open the SDK environment, select “File &gt; Launch SDK” in the top menu. | In the SDK, select “File &gt; New &gt; Application Project”. | Start by entering a name for your project. E.g. “lab1” | OS Platform: should be set to “standalone” | Hardware Platform: default setting, “soc_wrapper_hw_platform_0” | Processor: default setting, “microblaze_0” | Language: C | Board Support Package: Create New - e.g. “lab1_bsp” | Select “Next” to open the application templates page. | . | Select the “Hello World” template, and click “Finish” to create your application project. | In the “Project Explorer” window, open the file lab1/src/helloworld.c | Edit this program to print your name and student ID 5 times. | Pause! Now is a good time to make sure your FPGA dev board is plugged in. | Establish a serial connection with the FPGA’s serial port. | Open the “SDK Terminal” window. It will be in the bottom-center panel. | Click on the plus icon to open the “Connect to serial port” dialog. | Port: Select a COM port from the dropdown list. If there is more than one option, the COM port with the highest numerical suffix is usually the correct option. | Baud Rate: 9600 | Data bits: 8 | Stop bits: 1 | Parity: None | Flow Control: None | Click “OK” to start the connection. | . | Combine your hardware design and application project into a single bitstream and load it onto your FPGA board. | Start by selecting “Xilinx &gt; Program FPGA” in the top menu. Nothing to change on this window, select “Program” to load the bitstream onto the FPGA. | Next, select “Run &gt; Run As &gt; Launch On Hardware (System Debugger)” | Alternatively, select “Launch On Hardware (GDB)” to launch the application in debug mode where you will have the option to step through the program. Use this option when debugging your applications. | . | . ",
    "url": "/classes/embedded-systems/labs/lab1/#directions",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#directions"
  },"98": {
    "doc": "Lab 1",
    "title": "Submission",
    "content": ". | Prepare a lab report: (Use the lab report template provided) . | Give an account of what you did in this lab, what you learned, and anything you found interesting. | Include the screenshots of your Uartlite controller and neighboring components and the output of your “SDK Terminal” window. | Include essential relevant screenshots, diagrams, and code snippets necessary to your writing in the report. | . | Submit, separately, all your code files (e.g. the “helloworld.c” file). | NB: DO NOT paste your code in your lab report. | . | . ",
    "url": "/classes/embedded-systems/labs/lab1/#submission",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#submission"
  },"99": {
    "doc": "Lab 1",
    "title": "Prelab Questions",
    "content": ". | What is an FPGA? | What is a system-on-chip? Why is it different from your desktop computer system? | What does soft-core IP mean? | What does it mean to cross-compile a program? | Why does it take so long to configure/build the Hardware portion of your system on the FPGA? | How does the desktop computer program the FPGA, how does it monitor the FPGA? | . ",
    "url": "/classes/embedded-systems/labs/lab1/#prelab-questions",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#prelab-questions"
  },"100": {
    "doc": "Lab 1",
    "title": "Lab 1",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab1/",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/"
  },"101": {
    "doc": "Labs",
    "title": "Lab Repository",
    "content": " ",
    "url": "/classes/embedded-systems/labs/#lab-repository",
    
    "relUrl": "/classes/embedded-systems/labs/#lab-repository"
  },"102": {
    "doc": "Labs",
    "title": "Lab Schedule",
    "content": "| Date | Lab | . | 8/21 - 8/25 | Prelab: download Vivado 2019.1 on home computer | . | 09/04 - 09/08 | Lab 1: How to build a basic SoC | . | 09/11 - 09/15 | Lab 2: GPIOs + Basic MicroBlaze System | . | 09/18 - 09/22 | Lab 3: Fayetteville Bike Crossing | . | 10/02 - 10/06 | Lab 4: Timers | . | 10/09 - 10/13 | Lab 5: Interrupt Driven Microblaze System | . | 10/23 - 11/03 | Lab 6: Autonomous Vehicle | . ",
    "url": "/classes/embedded-systems/labs/#lab-schedule",
    
    "relUrl": "/classes/embedded-systems/labs/#lab-schedule"
  },"103": {
    "doc": "Labs",
    "title": "Lab Reports",
    "content": "You are required to complete a lab report after each lab. The report along with any code files from that lab will be due on Friday of the following week. Lab Report Template . ",
    "url": "/classes/embedded-systems/labs/#lab-reports",
    
    "relUrl": "/classes/embedded-systems/labs/#lab-reports"
  },"104": {
    "doc": "Labs",
    "title": "Grading",
    "content": "A rubric will be attached to each assignment on Blackboard. Make sure you read the rubric before you submit your assignment. ",
    "url": "/classes/embedded-systems/labs/#grading",
    
    "relUrl": "/classes/embedded-systems/labs/#grading"
  },"105": {
    "doc": "Labs",
    "title": "Labs",
    "content": " ",
    "url": "/classes/embedded-systems/labs/",
    
    "relUrl": "/classes/embedded-systems/labs/"
  },"106": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "EECS 4114/5114 Embedded Systems",
    "content": "| Arty-A7 Protoboard | Autonomous Vehicle | . | | | . ",
    "url": "/classes/embedded-systems/#eecs-41145114-embedded-systems",
    
    "relUrl": "/classes/embedded-systems/#eecs-41145114-embedded-systems"
  },"107": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "Course Description",
    "content": "The design and analysis of modern HW/SW co-designed embedded systems. Modern design flows and approaches for creating and controlling System on Chip integrated components. Real time and reactive modeling and implementation of control loops and data processing. System level integration techniques for multiprocessor components and accelerators. This class will make use of the Xilinx/Digilent Arty-A7-35 Development Board. This development board contains a modern Artix 7-series FPGA along with various peripherals such as Ethernet, USB, Audio In/Out, LEDs, buttons, switches, VGA, etc. Various System-On-Chip (SoC) architectures will be developed during this class, all of which will be implemented within the fabric of the FPGA. Most, if not all, of the SoCs developed during this class will use the MicroBlaze processor; a soft 32-bit processor core developed by Xilinx. The instruction set architecture, or ISA, of the MicroBlaze will be studied and used throughout this class, in order to teach students the relationships between high-level languages, assembly language, and the actual hardware implementation of computer systems. ",
    "url": "/classes/embedded-systems/#course-description",
    
    "relUrl": "/classes/embedded-systems/#course-description"
  },"108": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "Syllabus",
    "content": " ",
    "url": "/classes/embedded-systems/#syllabus",
    
    "relUrl": "/classes/embedded-systems/#syllabus"
  },"109": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "Textbook",
    "content": "EECS 4114: Embedded Systems, Frank Vahid, Tony Givargis, Bailey Miller, Zybooks . ",
    "url": "/classes/embedded-systems/#textbook",
    
    "relUrl": "/classes/embedded-systems/#textbook"
  },"110": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "Schedule",
    "content": "All lectures can be found through the following link: EECS 4114 Lecture Page. ",
    "url": "/classes/embedded-systems/#schedule",
    
    "relUrl": "/classes/embedded-systems/#schedule"
  },"111": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "Lab Repository",
    "content": "All lab projects can be found through the following link: EECS 4114 Lab Page. ",
    "url": "/classes/embedded-systems/#lab-repository",
    
    "relUrl": "/classes/embedded-systems/#lab-repository"
  },"112": {
    "doc": "EECS 4114 Embedded Systems",
    "title": "EECS 4114 Embedded Systems",
    "content": " ",
    "url": "/classes/embedded-systems/",
    
    "relUrl": "/classes/embedded-systems/"
  },"113": {
    "doc": "Classes",
    "title": "Classes",
    "content": " ",
    "url": "/classes/",
    
    "relUrl": "/classes/"
  },"114": {
    "doc": "Classes",
    "title": "Table Of Contents",
    "content": ". | Classes . | Graduate Classes Offered by the CSDL Lab . | EECS 5013 Post Moore’s Law Computer Architectures | EECS 5843 Reconfigurable Computing | Multiprocessor Systems-On-Chip | EECS 5013 Real-Time Operating Systems (RTOS) | EECS 5013 Adaptive Systems | . | Undergraduate Classes Offered by the CSDL Lab . | EECS 2214 Computer Organization | EECS 3613 Operating Systems | EECS 4114 Embedded Systems | EECS 4213 Computer Architecture | EECS 2114 Digital Design | . | . | . ",
    "url": "/classes/#table-of-contents",
    
    "relUrl": "/classes/#table-of-contents"
  },"115": {
    "doc": "Classes",
    "title": "Graduate Classes Offered by the CSDL Lab",
    "content": "EECS 5013 Post Moore’s Law Computer Architectures . The end of Dennard scaling and slowdown of Moore’s law has ushered in a new era called Post Moore’s Law Computing. This course will look at the trends, applications, and emerging architectures that are defining this new era. EECS 5843 Reconfigurable Computing . A graduate-level course on the state of the art in Reconfigurable Computing . Multiprocessor Systems-On-Chip . A graduate-level course that covers modern MPSoC design issues and methodologies. EECS 5013 Real-Time Operating Systems (RTOS) . A senior level/graduate-level course that covers real-time systems and the issues related to operating system design for those systems. EECS 5013 Adaptive Systems . A senior level/graduate-level course that gives student the basics of autonomic systems and have them design a workable adaptive system, conceptually and technically, based on the partial reconfiguration capabilities of FPGAs. ",
    "url": "/classes/#graduate-classes-offered-by-the-csdl-lab",
    
    "relUrl": "/classes/#graduate-classes-offered-by-the-csdl-lab"
  },"116": {
    "doc": "Classes",
    "title": "Undergraduate Classes Offered by the CSDL Lab",
    "content": "EECS 2214 Computer Organization . An introductory course in computer organization and architecture including topics in digital logic, digital systems, and memory structure. EECS 3613 Operating Systems . An introduction to operating systems including topics in concepts and system structures, process management, memory management, files and storage management, distributed systems, and case studies. EECS 4114 Embedded Systems . A senior level/graduate-level course that covers modern Computer Architecture. EECS 4213 Computer Architecture . A senior level/graduate-level course that covers modern Computer Architecture. EECS 2114 Digital Design . An undergraduate course that covers basic concepts of binary and digital systems, along with VHDL programming . ",
    "url": "/classes/#undergraduate-classes-offered-by-the-csdl-lab",
    
    "relUrl": "/classes/#undergraduate-classes-offered-by-the-csdl-lab"
  },"117": {
    "doc": "Home",
    "title": "Computer Systems Design Laboratory",
    "content": " ",
    "url": "/#computer-systems-design-laboratory",
    
    "relUrl": "/#computer-systems-design-laboratory"
  },"118": {
    "doc": "Home",
    "title": "Laboratory Overview",
    "content": ". Welcome to the Computer Systems Design Laboratory at the University of Arkansas. Research in CSDL encompasses system specification and verification, modeling abstractions, HW/SW co-design, CAD/CAE, operating systems, special purpose architectures, compilers, security, special computer architectures, and real-time embedded systems. Current research being done in the Computer Systems Design Laboratory (CSDL) can be viewed on our Projects page. Knowledge is also folded back into both the undergraduate and graduate curriculum in some of our Classes, Lab Notes, and through Reading Groups. The faculty of the CSDL hold primary teaching responsibility for departmental undergraduate classes in digital design, computer organization, computer architecture, embedded systems, and systems modeling. Graduate classes taught by CSDL faculty span reconfigurable computing, multiprocessor systems on chip (MPSoC), and asynchronous logic design. The CSDL hosts visiting researchers and scholars from other research groups world wide, and supports a colloquium series of invited experts. Undergraduate, Masters, and PhD students form the core of CSDL in an interdisciplinary and team based environment. We encourage you to explore the research and teaching components of our laboratory. ",
    "url": "/#laboratory-overview",
    
    "relUrl": "/#laboratory-overview"
  },"119": {
    "doc": "Home",
    "title": "Areas of Research",
    "content": ". | Real-Time and Embedded Systems Software | Reconfigurable Computing | Multiprocessor Systems on Chip (MPSoC) | Heterogeneous Computing | System Design | Computer Architecture | HW/SW Co-Design | Hardware Acceleration Technologies (FPGAs, GPUs, etc.) | . ",
    "url": "/#areas-of-research",
    
    "relUrl": "/#areas-of-research"
  },"120": {
    "doc": "Home",
    "title": "Home",
    "content": ". ",
    "url": "/",
    
    "relUrl": "/"
  },"121": {
    "doc": "People",
    "title": "Laboratory Personnel",
    "content": " ",
    "url": "/people/#laboratory-personnel",
    
    "relUrl": "/people/#laboratory-personnel"
  },"122": {
    "doc": "People",
    "title": "Professors",
    "content": "David Andrews . dandrews@uark.edu . Email . Miaqiong Huang . mqhuang@uark.edu . Email . ",
    "url": "/people/#professors",
    
    "relUrl": "/people/#professors"
  },"123": {
    "doc": "People",
    "title": "Students",
    "content": "Ehsan Kabir . ekabir@uark.edu . Mayeesha Mahzabin . mahzabin@uark.edu . MD Arafat Kabir . makabir@uark.edu . I am currently pursuing my Ph.D. while carrying out my role as a research assistant at the Computer Systems Design Lab at the CSCE department of the University of Arkansas. My doctoral research involves the investigation of a reconfigurable memory-centric array processor architecture for Deep-Learning Acceleration on FPGA. This architecture will open up the advantages of FPGA and in-memory processing to the broader Deep-Learning user community, offering abstraction and application-specific customization features. Nathaniel Fredricks . njfredri@uark.edu . I am a first-year graduate student in Computer Engineering. My main interests are reconfigurable computing and computer architecture. Shahrin Shahpar . sshahpar@uark.edu . Tendayi Kamucheka . tfkmauch@uark.edu . ",
    "url": "/people/#students",
    
    "relUrl": "/people/#students"
  },"124": {
    "doc": "People",
    "title": "People",
    "content": " ",
    "url": "/people/",
    
    "relUrl": "/people/"
  },"125": {
    "doc": "Publications",
    "title": "Publications",
    "content": " ",
    "url": "/publications/",
    
    "relUrl": "/publications/"
  },"126": {
    "doc": "Publications",
    "title": "Publications",
    "content": ". | 2023 | 2022 | 2021 | 2020 | 2019 | 2018 | 2016 | 2015 | 2014 | 2013 | 2012 | 2011 | 2010 | 2009 | 2008 | 2007 | 2006 | 2005 | 2004 | 2003 | . ",
    "url": "/publications/",
    
    "relUrl": "/publications/"
  },"127": {
    "doc": "Publications",
    "title": "2023",
    "content": ". | MD Arafat Kabir, Ehsan Kabir, Joshua Hollis, Eli Levy-Mackay, Atiyehsadat Panahi, Jason Bakos, Miaoqing Huang, and David Andrews, “FPGA Processor In Memory Architectures (PIMs): Overlay or Overhaul?” The 33rd International Conference on Field-Programmable Logic and Applications (FPL 2023), pp. 1-7, September 2023. arXiv | Ehsan Kabir, Daniel Coble, Joud N. Satme, Austin R.J. Downey, Jason D. Bakos, David Andrews, and Miaoqing Huang, “Accelerating LSTM-based High-Rate Dynamic System Models,” The 33rd International Conference on Field-Programmable Logic and Applications (FPL 2023), pp. 1-6, September 2023. | MD Arafat Kabir, Joshua Hollis, Atiyehsadat Panahi, Jason Bakos, Miaoqing Huang, and David Andrews, “Making BRAMs Compute: Creating Scalable Computational Memory Fabric Overlays,” The 31st IEEE International Symposium On Field-Programmable Custom Computing Machines (FCCM 2023), pp. 1-1, May 2023. IEEE | . ",
    "url": "/publications/#2023",
    
    "relUrl": "/publications/#2023"
  },"128": {
    "doc": "Publications",
    "title": "2022",
    "content": ". | T. Kamucheka, A. Nelson, D. Andrews and M. Huang, “A Masked Pure-Hardware Implementation of Kyber Cryptographic Algorithm,” 2022 International Conference on Field-Programmable Technology (ICFPT), Hong Kong, 2022, pp. 1-1, IEEE | A. Panahi, E. Kabir, A. Downey, D. Andrews, M. Huang and J. D. Bakos, “High-Rate Machine Learning for Forecasting Time-Series Signals,” 2022 IEEE 30th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), New York City, NY, USA, 2022, pp. 1-9, IEEE | Kabir, E., Poudel, A., Aklah, Z., Huang, M., Andrews, D. (2022). A Runtime Programmable Accelerator for Convolutional and Multilayer Perceptron Neural Networks on FPGA. In: Gan, L., Wang, Y., Xue, W., Chau, T. (eds) Applied Reconfigurable Computing. Architectures, Tools, and Applications. ARC 2022. Lecture Notes in Computer Science, vol 13569. Springer, Cham. Springer | H. Liu, A. Panahi, D. Andrews and A. Nelson, “An FPGA-Based Upper-Limb Rehabilitation Device for Gesture Recognition and Motion Evaluation Using Multi-Task Recurrent Neural Networks,” in IEEE Sensors Journal, vol. 22, no. 4, pp. 3605-3615, 15 Feb.15, 2022, IEEE. | . ",
    "url": "/publications/#2022",
    
    "relUrl": "/publications/#2022"
  },"129": {
    "doc": "Publications",
    "title": "2021",
    "content": ". | A. Panahi, S. Balsalama, A. -T. Ishimwe, J. M. Mbongue and D. Andrews, “A Customizable Domain-Specific Memory-Centric FPGA Overlay for Machine Learning Applications,” 2021 31st International Conference on Field-Programmable Logic and Applications (FPL), Dresden, Germany, 2021, pp. 24-27, IEEE. | Tendayi Kamucheka, Michael Fahr, Tristen Teague, Alexander Nelson, David Andrews, and Miaoqing Huang, “Power-based Side Channel Attack Analysis on PQC Algorithms”, Cryptology ePrint Archive, 2021 url | . ",
    "url": "/publications/#2021",
    
    "relUrl": "/publications/#2021"
  },"130": {
    "doc": "Publications",
    "title": "2020",
    "content": ". | S. Basalama, A. Panahi, A. -T. Ishimwe and D. Andrews, “SPAR-2: A SIMD Processor Array for Machine Learning in IoT Devices,” 2020 3rd International Conference on Data Intelligence and Security (ICDIS), South Padre Island, TX, USA, 2020, pp. 141-147, IEEE | H. Liu, A. Panahi, D. Andrews and A. Nelson, “FPGA-Based Gesture Recognition with Capacitive Sensor Array using Recurrent Neural Networks,” 2020 IEEE 28th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), Fayetteville, AR, USA, 2020, pp. 225-225, IEEE | . ",
    "url": "/publications/#2020",
    
    "relUrl": "/publications/#2020"
  },"131": {
    "doc": "Publications",
    "title": "2019",
    "content": ". | A. Panahi, K. Stokke and D. Andrews, “A Library of FSM-based Floating-Point Arithmetic Functions on FPGAs,” 2019 International Conference on ReConFigurable Computing and FPGAs (ReConFig), Cancun, Mexico, 2019, pp. 1-8, IEEE | Hansmeier, T., Platzner, M., Pantho, M.J.H. et al. An Accelerator for Resolution Proof Checking based on FPGA and Hybrid Memory Cube Technology. J Sign Process Syst 91, 1259–1272 (2019). Journal of Signal Processing Systems | . ",
    "url": "/publications/#2019",
    
    "relUrl": "/publications/#2019"
  },"132": {
    "doc": "Publications",
    "title": "2018",
    "content": ". | M. J. H. Pantho, J. Mandebi Mbongue, C. Bobda and D. Andrews, “Transparent Acceleration of Image Processing Kernels on FPGA-Attached Hybrid Memory Cube Computers,” 2018 International Conference on Field-Programmable Technology (FPT), Naha, Japan, 2018, pp. 342-345, IEEE | J. Mbongue, F. Hategekimana, D. Tchuinkou Kwadjo, D. Andrews and C. Bobda, “FPGAVirt: A Novel Virtualization Framework for FPGAs in the Cloud,” 2018 IEEE 11th International Conference on Cloud Computing (CLOUD), San Francisco, CA, USA, 2018, pp. 862-865, IEEE | M. J. H. Pantho, J. M. Mbongue, C. Bobda, D. Andrews and M. Asadinia, “Enabling Transparent Acceleration of OpenCV Library Kernels on a Hybrid Memory Cube Computer,” 2018 IEEE 26th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), Boulder, CO, USA, 2018, pp. 217-217, IEEE | Hansmeier, T., Platzner, M., Andrews, D. (2018). An FPGA/HMC-Based Accelerator for Resolution Proof Checking. In: Voros, N., Huebner, M., Keramidas, G., Goehringer, D., Antonopoulos, C., Diniz, P. (eds) Applied Reconfigurable Computing. Architectures, Tools, and Applications. ARC 2018. Lecture Notes in Computer Science(), vol 10824. Springer | Sen Ma, Xuan Shi &amp; David Andrews (2018) Parallelizing maximum likelihood classification (MLC) for supervised image classification by pipelined thread approach through high-level synthesis (HLS) on FPGA cluster, Big Earth Data, 2:2, 144-158, https://doi.org/10.1080/20964471.2018.1470249 | . ",
    "url": "/publications/#2018",
    
    "relUrl": "/publications/#2018"
  },"133": {
    "doc": "Publications",
    "title": "2016",
    "content": ". | S. Ma, D. Andrews, S. Gao and J. Cummins, “Breeze computing: A just in time (JIT) approach for virtualizing FPGAs in the cloud,” 2016 International Conference on ReConFigurable Computing and FPGAs (ReConFig), Cancun, Mexico, 2016, pp. 1-6,IEEE | H. Ding, S. Ma, M. Huang and D. Andrews, “OOGen: An Automated Generation Tool for Custom MPSoC Architectures Based on Object-Oriented Programming Methods,” 2016 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW), Chicago, IL, USA, 2016, pp. 233-240, IEEE | Eugene Cartwright, “Enabling Runtime Profiling to Hide and Exploit Heterogeneity within Chip Heterogeneous Multiprocessor Systems (CHMPS)”, Ph.D. Dissertation at the University of Arkansas (May, 2016). Dissertation | Invited Talk “JIT Run Time Assembly of Hardware Accelerators”, Paderborn University, Paderborn Germany, June 30, 2016 | Invited Paper David Andrews, Marco Platzner, “Programming Models for Reconfigurable Manycore Systems” Proceedings of the 11th International Symposium on Reconfigurable Communication-centric Systems-on-Chip (ReCoSoC 2016) Tallinn, Estonia June 27-29, 2016 pp. 1-8 IEEE | S. Ma, Z. Aklah and D. Andrews, “Run time interpretation for creating custom accelerators,” 2016 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE), Dresden, Germany, 2016, pp. 900-905 IEEE | Sen Ma, Zeyad Aklah, David Andrews, “Just In Time Assembly of Accelerators”, Proceedings of the 24th ACM/SIGDA International Symposium on Field-Programmable Gate Arrays (FPGA 2016), Monterey California, February 21-23, 2016 pp. 173-178, https://arxiv.org/abs/1603.01187 | Zeyad Aklah, Sen Ma and David Andrews, “A Dynamic Overlay Supporting Just-In-Time Assembly to Construct Customized Hardware Accelerators” 2nd International Workshop on Overlay Architectures for FPGAs (OLAF). Sunday workshop at the 24th ACM/SIGDA International Symposium on Field-Programmable Gate Arrays (FPGA 2016) 2 page abstract. | . ",
    "url": "/publications/#2016",
    
    "relUrl": "/publications/#2016"
  },"134": {
    "doc": "Publications",
    "title": "2015",
    "content": ". | Sen Ma, Hongyuan Ding, Miaoqing Huang and David Andrews, “Archborn: An Open Source Tool for Automated Generation of Chip Heterogeneous Multiprocessor Architectures”, Proceedings of the International Conference on ReConFigurable Computing and FPGAs, Cancun Mexico, Dec 7-9, 2015 | Nithin George, Hyoukloong Lee, David Novo, Muhsen Owaida, Davi Andrews, Kunle Olukotun, and Paolo Ienne,”Automatic Support for Multi-Module Parallelism from Computational Patterns”, Proceedings of the 25th International Conference on Field Programmable Logic and Applications (FPL) pp.93-100, London, England, 2015 | Sen Ma, Zeyad Aklah and David Andrews, “A Run Time Interpretation Approach for Creating Custom Accelerators”, Proceedings of the 25th International Conference on Field Programmable Logic and Applications (FPL), pp.472-475, London, England, 2015 | Paolo Ienne, David Andrews, Walid Najjar, Reconfigurable Computing for the Masses, Really ? Workshop at the 25th International Conference on Field Programmable Logic and Applications (FPL) London, England, 2015 | David Andrews, Can We Finally Allow Software Programmers to Create Hardware Accelerators ? Invited Talk at ETH Zurich, April 30, 2015 | Keynote Talk David Andrews, Will the future success of Reconfigurable Computing require a paradigm shift in our research communities thinking?, 11th International Symposium on Applied Reconfigurable Computing (ARC), Bochum Germany, April 16, 2015 | Zeyad Aklah and David Andrews, “A Flexible Multilayer Perceptron Co-Processor for FPGAs” Proceedings of the 11th International Symposium on Applied Reconfigurable Computing (ARC), pp. 427-434, Bochum Germany, April 13-17, 2015 | . ",
    "url": "/publications/#2015",
    
    "relUrl": "/publications/#2015"
  },"135": {
    "doc": "Publications",
    "title": "2014",
    "content": ". | Cartwright, Eugene; Sadeghian, Alborz; Ma, Sen; Andrews, David, “Achieving Portability and Efficiency over Chip Heterogeneous Multiprocessor Systems,” Field Programmable Logic and Applications (FPL), 2014 24th International Conference on, pp.1-4, 2-4 Sept. 2014 | Sen Ma, David L. Andrews: On energy efficiency and Amdahl’s law in FPGA based chip heterogeneous multiprocessor systems (abstract only). FPGA 2014: 253 | David Andrews, “Operating Systems Research for Reconfigurable Computing”, IEEE Micro, vol.34, no. 1, pp. 54-58, Jan.-Feb. 2014, doi:10.1109/MM.2014.1 | . ",
    "url": "/publications/#2014",
    
    "relUrl": "/publications/#2014"
  },"136": {
    "doc": "Publications",
    "title": "2013",
    "content": ". | Gerard Allwein, William Harrison and David Andrews,Simulation Logic Journal of Logic and Logical Philosophy, DOI: 10.12775/LLP.2013.0127, September 2013 | Miaoqing Huang and David Andrews, Modular Design of Fully Pipelined Reduction Circuits on FPGAs, IEEE Transactions on Parallel and Distributed Systems, Vol. 24, No 9., Sept. 2013, pp.1818-1826 | . ",
    "url": "/publications/#2013",
    
    "relUrl": "/publications/#2013"
  },"137": {
    "doc": "Publications",
    "title": "2012",
    "content": ". | Sen Ma, Miaoqing Huang, David Andrews, Developing Application-Specific Multiprocessor Platforms on FPGAs, Poster session of Reconfig 2012 | E. Cartwright, A. Fahkari, Sen Ma, C. Smith, M. Huang, D. Andrews, Jason Agron, Automating the Design of MLUT MPSOPC FPGA’s in the Cloud, Proceedings of the 22nd International Conference on Field Programmable Logic and Applications (FPL), Oslo, Norway, August 29-31, 2012 | Miaoqing Huang and Liang Men, Improving the Performance of On-Board Cache for Flash-based Solid-State Drives, in Proceedings of The 7th IEEE International Conference on Networking, Architecture, and Storage (NAS 2012), Xiamen, China, June 28-30, 2012. | D. Andrews, Visions for RC in the Next Twenty Years, Presentation at Sunday Workshop on Reconfigurable Computing and FCCM: What have we done in 20 years, and what will Reconfigurable Computing mean in 2032?, FCCM2012, April 2012. | Sen Ma, Miaoqing Huang, Eugene Cartwright, and David Andrews, Scalable Memory Hierarchies for Embedded Manycore Systems, in Proceedings of The 8th International Symposium on Applied Reconfigurable Computing (ARC 2012), LNCS 7199, pp. 151-162, Hong Kong, China, March 19-23, 2012. | . ",
    "url": "/publications/#2012",
    
    "relUrl": "/publications/#2012"
  },"138": {
    "doc": "Publications",
    "title": "2011",
    "content": ". | J. Agron, D. Andrews, M. Happe, E. Lubbers, and M. Platzner, Multithreaded Programming of Reconfigurable Embedded Systems, in Reconfigurable Embedded Control Systems: Applications for Flexibility and Agility, M. Khalgui and H.-M. Hanisch, Eds. Information Science Publishing, 2011, ch. 2, pp. 31–54. | Miaoqing Huang, Kris Gaj, and Tarek El-Ghazawi, New Hardware Architectures for Montgomery Modular Multiplication Algorithm, IEEE Transactions on Computers, vol. 60, no. 7, pp. 923-936, July 2011. | Ozlem Kilic, Miaoqing Huang, Charles Conner, and Mark S. Mirotznik, Hardware Accelerated Design of Millimeter Wave Antireflective Surfaces: A Comparison of Field-Programmable Gate Array (FPGA) and Graphics Processing Unit (GPU) Implementations, ACES (The Applied Computation Electromagnetics Society) Journal, vol. 26, no. 3, pp. 188-198, March 2011. | Liang Zhou, Miaoqing Huang, and Scott C. Smith, High-Performance and Area-Efficient Hardware Design for Radix-2^k Montgomery Multipliers, in Proceedings of The 2011 International Conference on Computer Design (CDES’11), Las Vegas, USA, July 18-21, 2011. | David Andrews, Design Flows and Run Time Systems for Heterogeneous Multiprocessor Systems on Programmable Chips (MPSoPCs), Printed abstract in Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms, Las Vegas, USA, July 18-21, 2011 pp.253-254 | Lingyuan Wang, Miaoqing Huang, and Tarek El-Ghazawi, Exploiting Concurrent Kernel Execution on Graphic Processing Units, in Proceedings of The 2011 International Conference on High Performance Computing &amp; Simulation (HPCS 2011), pp. 24-32, Istanbul, Turkey, July 4-8, 2011. (Acceptance ratio: 48/171=28.07%) | Eugene Cartwright, Sen Ma, David Andrews, and Miaoqing Huang, Creating HW/SW Co-Designed MPSoPC’s from High Level Programming Models, in Proceedings of Workshop on Multiprocessor Systems on (Programmable) Chips (MPSoC 2011) as part of The 2011 International Conference on High Performance Computing &amp; Simulation (HPCS 2011), pp. 554-560, Istanbul, Turkey, July 4-8, 2011. | Lingyuan Wang, Miaoqing Huang, Vikram K. Narayana, and Tarek El-Ghazawi, Scaling Scientific Applications on Clusters of Hybrid Multicore/GPU Nodes, in Proceedings of The 8th ACM International Conference on Computing Frontiers (CF’11), Ischia, Italy, May 3-5, 2011. (Acceptance ratio: 22/101=21.8%) | Jorge Ortiz and David Andrews, A Streaming High-Throughput Linear Sorter System with Contention Buffering, International Journal of Reconfigurable Computing, vol. 2011, Article ID 963539, 12 pages, 2011. doi:10.1155/2011/963539 | . ",
    "url": "/publications/#2011",
    
    "relUrl": "/publications/#2011"
  },"139": {
    "doc": "Publications",
    "title": "2010",
    "content": ". | Miaoqing Huang, David Andrews, and Jason Agron, “Operating System Structures for Multiprocessor Systems on Programmable Chip,” in Proceedings of 2010 International Conference on ReConFigurable Computing and FPGAs (ReConFig 2010), Cancun, Mexico, Dec. 13-15, 2010. | David Andrews, Building Heterogeneous Systems With a Hardware Microkernel Presentation given at Xilinx, San Jose, California, August 16, 2010 | Miaoqing Huang and David Andrews, Modular Design of Fully Pipelined Accumulators, in Proceedings of The 2010 International Conference on Field-Programmable Technology (FPT’10), Beijing, China, Dec. 8-10, 2010. | Jason Agron, Hardware Microkernels - A Novel Method for Constructing Operating Systems for Heterogeneous Multi-Core Platforms, Ph.D. Dissertation at the University of Arkansas (August, 2010). Dissertation and Presentation Slides. | David Andrews, Christian Plessl, Configurable Processor Architectures: History and Trends, Abstract of Invited Talk in Proceedings of the 10th International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA), Las Vegas, Nevada USA, July 12-15, 2010 | Miaoqing Huang, Lingyuan Wang, and Tarek El-Ghazawi, “Accelerating Double Precision Floating-point Hessenberg Reduction on FPGA and Multicore Architectures,” in Proceedings of 2010 Symposium on Application Accelerators in High Performance Computing (SAAHPC’10), Knoxville, Tennessee, USA, July 13-15, 2010. | David Andrews, Reconfigurable Architectures in the Heterogeneous Manycore Era, Proceedings of the 8th International Conference on High Performance Computing and Simulation (HPCS2010), Keynote Speech in the Special Session on Embedded and Reconfigurable Computing (ERC2010) Caen France, June 28-July 2, 2010 | Miaoqing Huang, Olivier Serres, Vikram K. Narayana, Tarek El-Ghazawi, and Gregory Newby, “Efficient Cache Design for Solid-State Drives,” in Proceedings of The ACM International Conference on Computing Frontiers 2010 (CF’10), pp. 41-50, Bertinoro, Italy, May 17-19, 2010. (Acceptance ratio: 30/113=26.5%) | Jason Agron and David Andrews, Distributed Hardware-Based Microkernels: Making Heterogeneous OS Functionality A System Primitive, Proceedings of The 18th Annual IEEE Symposium on Field-Programmable Custom Computing Machines, Charlotte, North Carolina. May 2-4, 2010. | Miaoqing Huang and Ozlem Kilic, “Reaping the processing potential of FPGA on double-precision floating-point operations: an eigenvalue solver case study,” in Proceedings of the 18th Annual International IEEE Symposium on Field-Programmable Custom Computing Machines (FCCM 2010), pp. 95-102, Charlotte, North Carolina, USA, May 2-4, 2010. (Acceptance ratio: 24/132=18.2%) | Ozlem Kilic, Miaoqing Huang, Charles Conner, and Mark S. Mirotznik, “Hardware Accelerated Design of Millimeter Wave Antireflective Surfaces,” in Proceedings of the 26th ACES Conference (ACES 2010), Tampere, Finland, April 25-29, 2010. | Jorge Ortiz and David Andrews, A Configurable High-Throughput Linear Sorter System , Proceedings of the 17th Reconfigurable Architectures Workshop (RAW) at International Symposium on Parallel and Distributed Systems (IPDPS), Atlanta, Georgia April 19-23, 2010 Presentation (PDF) | Ozlem Kilic and Miaoqing Huang, “Overview of Reconfigurable Computing Platforms and Their Applications in Electromagnetics Applications”, ACES (The Applied Computation Electromagnetics Society) Journal, vol.25, no.4, pp.283-293, April, 2010. | Miaoqing Huang, Olivier Serres, and Tarek El-Ghazawi, and Gregory Newby, “Parameterized Hardware Design on Reconfigurable Computers: An Image Processing Case Study,” International Journal of Reconfigurable Computing, vol.2010, pp.1-11, April, 2010, doi:10.1155/2010/454506. | Jason Agron and David Andrews, Efficient OS Services for Heterogeneous and Reconfigurable Manycores, Proceedings of the Many-Core and Reconfigurable Supercomputing Conference (MRSC’2010), Rome, Italy. | . ",
    "url": "/publications/#2010",
    
    "relUrl": "/publications/#2010"
  },"140": {
    "doc": "Publications",
    "title": "2009",
    "content": ". | Jason Agron and David Andrews, Building Heterogeneous Reconfigurable Systems With a Hardware Microkernel. Proceedings of the 7th International Conference on Hardware/Software Codesign and System Synthesis, CODES+ISSS, Grenoble, France, October 2009. Presentation (PDF) | Jason Agron and David Andrews, Hardware Microkernels for Heterogeneous Manycore Systems. Proceedings of the First International Workshop on Real-time Systems on Multicore Platforms: Theory and Practice (XRTS) held in conjunction with the 38th International Conference on Parallel Processing (ICPP), Vienna, Austria, September 2009. | Jason Agron and David Andrews, Building Heterogeneous Reconfigurable Systems Using Threads. Proceedings of the 19th International Conference on Field Programmable Logic and Applications (FPL), Prague, Czech Republic, September 2009. | Teng Li, Miaoqing Huang, Tarek El-Ghazawi, and H. Howie Huang, “Reconfigurable Active Disk: An FPGA Accelerated Storage Architecture for Data-Intensive Applications,” in Proceedings of 2009 Symposium on Application Accelerators in High-Performance Computing (SAAHPC’09), Urbana, Illinois, USA, July 28-30, 2009. | Jason Agron, Domain-Speciﬁc Language for HW/SW Co-Design for FPGAs (PRE-PRINT). Proceedings of the IFIP Working Conference on Domain Specific Languages (DSL WC), Volume 5658 of Lecture Notes in Computer Science, pages 262-284. Springer-Verlag, July, 2009. | William Harrison, Adam Procter, Jason Agron, Garrin Kimmell, and Gerard Allwein, Model-driven Engineering from Modular Monadic Semantics: Implementation Techniques Targeting Hardware and Software (PRE-PRINT). Proceedings of the IFIP Working Conference on Domain Specific Languages (DSL WC), Volume 5658 of Lecture Notes in Computer Science, pages 20-44. Springer-Verlag, July, 2009. | Jason Agron and David Andrews, Hardware Microkernels for Heterogeneous Manycore Systems. Proceedings of the Fifth International Workshop on Operating Systems Platforms for Embedded Real-Time Applications (OSPERT), Dublin, Ireland, June, 2009. | Miaoqing Huang, Harald Simmler, Olivier Serres, and Tarek El-Ghazawi, “RDMS: A Hardware Task Scheduling Algorithm for Reconfigurable Computing,” in Proceedings of the 16th Reconfigurable Architectures Workshop (RAW 2009), Rome, Italy, May 25-26, 2009. | Miaoqing Huang, Vikram K. Narayana, and Tarek El-Ghazawi, “Efficient mapping of hardware tasks on reconfigurable computers using libraries of architecture variants,” in Proceedings of the Seventeenth Annual IEEE Symposium on Field-Programmable Custom Computing Machines (FCCM’09), pp. 247-250, Napa, CA, USA, April 5-7, 2009. | Miaoqing Huang, Olivier Serres, Tarek El-Ghazawi, and Greg Newby, “Parameterized Hardware Design on Reconfigurable Computers: An Image Registration Case Study”, in Proceedings of V Southern Conference on Programmable Logic (SPL 2009), pp.71-76, Sao Carlos, Brazil, April 1-3, 2009. | . ",
    "url": "/publications/#2009",
    
    "relUrl": "/publications/#2009"
  },"141": {
    "doc": "Publications",
    "title": "2008",
    "content": ". | D. Andrews, Increasing Design Productivity for Next Generation Platform FPGA’s , Presentation at the ICFPT08 Pre-Workshop on FPGA Design Productivity, December 2008 | Miaoqing Huang, Harald Simmler, Proshanta Saha, and Tarek El-Ghazawi, “Hardware Task Scheduling Optimizations for Reconfigurable Computing,” in Proceedings of the Second International Workshop on High-Performance Reconfigurable Computing Technology and Applications (HPRCTA’08), Austin, Texas, USA, Nov. 17, 2008. | Miaoqing Huang, Olivier Serres, Tarek El-Ghazawi, and Greg Newby, “Implementing Image Registration Algorithms on Reconfigurable Computer,” in Proceedings of 10th Military and Aerospace Programmable Logic Devices Conference (MAPLD 2008), Annapolis, Maryland, USA, Sept. 15-18, 2008. | D. Andrews, J. Agron, Modeling Abstractions for Next-Generation Reconfigurable Computing, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA) July 2008 | Miaoqing Huang, Ivan Gonzalez, Sergio Lopez-Buedo, and Tarek El-Ghazawi, “A Framework to Improve IP Portability on Reconfigurable Computers,” in Proceedings of The 10th International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA 2008), pp.191-197, Las Vegas, Nevada, USA, July 14-17, 2008. | Miaoqing Huang, Esam El-Araby, and Tarek El-Ghazawi, “Divide-and-Conquer Approach for Designing Large-operand Functions on Reconfigurable Computers,” in Proceedings of the 4th Reconfigurable Systems Summer Institute, 2008 (RSSI’08), Urbana, Illinois, USA, July 7-9, 2008. | Santner, S., Peck, W., Agron, J., and Andrews, D., Symmetric Multiprocessor Design for Hybrid CPU/FPGA SoCs, Proceedings of the 4th International Workshop on Applied Reconfigurable Computing (ARC 2008) in Lecture Notes in Computer Science, Springer-Verlag, Number 4943, pp. 99 - 110, 2008 | Proshanta Saha, Esam El-Araby, Miaoqing Huang, Mohamed Taher, Sergio Lopez-Buedo,Tarek El-Ghazawi, Chang Shu, Kris Gaj, Alan Michalski, and Duncan Buell, “Portable library development for reconfigurable computing systems: A case study,” Parallel Computing, vol.34, no.4+5, pp.245-260, May, 2008. | Elias Teodoro Silva Jr., David Andrews, Carlos Eduardo Pereira, and Flavio Rech Wagner An Infrastructure for Hardwdare-Software Co-Design of Embedded Real-Time Java Applications, Proceedings of the 11th IEEE International Symposium on Object-Oriented Real-Time Distributed Computing (ISORC 2008) pp. 273-280, May 2008. | Miaoqing Huang, Olivier Serres, Sergio Lopez-Buedo, Tarek El-Ghazawi, and Greg Newby, “An Image Processing Architecture To Exploit I/O Bandwidth on Reconfigurable Computers,” in Proceedings of IEEE IV Southern Conferece on Programmable Logic (SPL 2008), pp.257-260, Bariloche-Patagonia, Argentina, March 26-28, 2008. | Miaoqing Huang, Kris Gaj, Soonhak Kwon, and Tarek El-Ghazawi, “An Optimized Hardware Architecture for the Montgomery Multiplication Algorithm,” in Proceedings of The 11th International Workshop on Practice and Theory in Public Key Cryptography (PKC 2008), LNCS vol.4939, pp.214-228, March 9-12, 2008. | Tarek El-Ghazawi, Esam El-Araby, Miaoqing Huang, Kris Gaj, Volodymyr Kindratenko, and Duncan Buell, “The promise of high-performance reconfigurable computing,” IEEE Computer, vol.41, no.2, pp.69-76, Feb. 2008. | D. Andrews, R. Sass, E. Anderson, J. Agron, W. Peck, J. Stevens, F. Baijot, and E. Komp, Achieving Programming Model Abstractions For Reconﬁgurable Computing, IEEE Transactions on Very Large Scale Integration (VLSI) Systems, vol. 16, no. 1, pp. 34–44, January 2008. | . ",
    "url": "/publications/#2008",
    
    "relUrl": "/publications/#2008"
  },"142": {
    "doc": "Publications",
    "title": "2007",
    "content": ". | Miaoqing Huang, Ivan Gonzalez, and Tarek El-Ghazawi, “A Portable Memory Access Framework on Reconfigurable Computers,” in Proceedings of IEEE 2007 International Conference on Field-Programmable Technology (ICFPT’07), pp. 333-336, December 12-14, 2007. | Thamer Abuyasin, Enabling Task Level Parallelism In Handel-C, Master’s Thesis at the University of Kansas (December, 2007). Thesis and presentation slides. | Erik Anderson, Wesley Peck, Jim Stevens, Jason Agron, Fabrice Baijot, Seth Warn, and David Andrews, Supporting High-Level Language Semantics Within Hardware Resident Threads, 17th International Conference on Field Programmable Logic and Applications, August 2007. pp. 98-103. | Jim Stevens, Hybridthreads Compiler: Generation of Application Specific Hardware Thread Cores from C, Ph.D. Forum at the 17th International Conference on Field Programmable Logic and Applications, August 2007. | Erik Anderson, Abstracting the Hardware/Software Boundary through a Standard System Support Layer and Architecture, Ph.D. Dissertation at the University of Kansas (May, 2007). Thesis and presentation slides. | Erik Anderson, Wesley Peck, Jim Stevens, Jason Agron, Fabrice Baijot, Seth Warn, and David Andrews, Memory Hierarchy for MCSoPC Multithreaded Systems, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA) June 2007. | Ron Sass, William V. Kritikos, Andrew G. Schmidt, Srinivas Beeravolu, Parag Beeraka, Kushal Datta, David Andrews, Richard S. Miller, and Daniel Stanzione, Jr. Reconfigurable Computing Cluster (RCC) Project: Investigating the Feasibility of FPGA-Based Petascale Computing, Proceedings of the Fifteenth Annual IEEE Symposium on Field-Programmable Custom Computing Machines, Napa, CA. April 2007. | Miaoqing Huang, Tarek El-Ghazawi, Brian Larson, and Kris Gaj, “Development of Block-Cipher Library for Reconfigurable Computers,” in Proceedings of IEEE III Southern conference on Programmable Logic (SPL 2007), pp.191-194, February 26-28, 2007. | . ",
    "url": "/publications/#2007",
    
    "relUrl": "/publications/#2007"
  },"143": {
    "doc": "Publications",
    "title": "2006",
    "content": ". | Jason Agron, Wesley Peck, Erik Anderson, David Andrews, Ed Komp, Ron Sass, Fabrice Baijot, and Jim Stevens, Run-Time Services for Hybrid CPU/FPGA Systems on Chip, Proceedings of the 27th IEEE International Real-Time Systems Symposium, Rio De Janeiro, Brazil, December 2006 pp. 3 - 12. File:Rtss06.pdf | Wesley Peck, Erik Anderson, Jason Agron, Jim Stevens, Fabrice Baijot, and David Andrews, Hthreads: A Computational Model for Reconfigurable Devices, Proceedings of the 16th International Conference on Field Programmable Logic and Applications (FPL) August 2006. pp. 885-888 File:Fpl06.pdf | David Andrews, Ron Sass, Erik Anderson, Jason Agron, Wesley Peck, Jim Stevens, Fabrice Baijot and Ed Komp,, The Case for High level Programming Models for Reconfigurable Computers, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA) June 2006. File:Ersa06.pdf | Jason Agron, Run-Time Scheduling Support for Hybrid CPU/FPGA SoCs, Master’s Thesis at the University of Kansas (April, 2006). Thesis and presentation Slides | Erik Anderson, Jason Agron, Wesley Peck, Jim Stevens, Fabrice Baijot, Ed Komp, Ron Sass, David Andrews, Enabling a Uniform Programming Model Across the Software/Hardware Boundary, Proceedings of The Fourteenth Annual IEEE Symposium on Field-Programmable Custom Computing Machines, Napa Valley, CA, 24-26 April 2006. File:Fccm06.pdf | . ",
    "url": "/publications/#2006",
    
    "relUrl": "/publications/#2006"
  },"144": {
    "doc": "Publications",
    "title": "2005",
    "content": ". | Razali Jidin, Extending the Thread Programming Model Across Hybrid FPGA/CPU Architectures, Ph.D. Dissertation at the University of Kansas (April, 2005). Thesis and presentations slides | David Andrews, Wesley Peck, Jason Agron, Keith Preston, Ed Komp, Mike Finley, Ron Sass, hthreads: A Hardware/Software Co-Designed Multithreaded RTOS Kernel, Proceedings of the 10th IEEE International Conference on Emerging Technologies and Factory Automation Facolta’ di Ingegneria, Catania, Italy, 19-22 September 2005. File:Etfa05.pdf | David Andrews, Iain Bate, Thomas Nolte, Clara M. Otero Perez, Stefan M. Petters, Impact of Embedded Systems Evolution on RTOS Use and Design, Proceedings of the 1st International Workshop Operating System Platforms for Embedded Real-Time Applications (OSPERT’05) in conjunction with the 17th Euromicro International Conference on Real-Time Systems (ECRTS’05), p 13-19, Palma de Mallorca, Balearic Islands, Spain. File:Ospert.pdf | R. Jidin, D. Andrews, W. Peck, D. Chirpich, K. Stout, J. Gauch, Evaluation of the Hybrid Multithreading Programming Model using Image Processing Transform, Proceedings of the 12th Reconfigurable Architectures Workshop (RAW 2005), April 4-5, 2005, Denver, Colorado, USA. File:Hwimage.pdf | . ",
    "url": "/publications/#2005",
    
    "relUrl": "/publications/#2005"
  },"145": {
    "doc": "Publications",
    "title": "2004",
    "content": ". | W. Peck, J. Agron, D. Andrews, M. Finley, E. Komp, Hardware/Software Co-Design of Operating System Services for Thread Management and Scheduling, In Proceedings of the 25th IEEE International Real-Time Systems Symposium, Works In Progress Session (RTSS, WIP 2004). Lisbon, Portugal, December 5-8, 2004. File:RTSS wesley.pdf | J. Agron, D. Andrews, M. Finley, E. Komp, W. Peck, FPGA Implementation of a Priority Scheduler Module, In Proceedings of the 25th IEEE International Real-Time Systems Symposium, Works In Progress Session (RTSS, WIP 2004). Lisbon, Portugal, December 5-8, 2004. File:RTSS FPGA Scheduler.pdf | R. Jidin, D. Andrews, D. Niehaus, W. Peck, Fast Synchronization Primitives for Hybrid CPU/FPGA Multithreading, In Proceedings of the 25th IEEE International Real-Time Systems Symposium, Works In Progress Session (RTSS, WIP 2004). Lisbon, Portugal, December 5-8, 2004. Online Proceedings (Pages 27-31) | Andrews, D., Niehaus, D., Jidin, R., Finley, M., Peck, W., Frisbee, M., Ortiz, J. Komp, E., Ashenden, P., Programming Models for Hybrid FPGA/CPU Computational Components: A Missing Link, IEEE Micro, July/August 2004. File:Micro.pdf | Jidin, R., Andrews, D., Niehaus, D., Implementing Multi Threaded System Support for Hybrid Computational Components, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA), June 2004, Las Vegas, Nevada. File:ERSA2004.pdf | Andrews, D., Niehaus, D., Jidin, R., Implementing the Thread Programming Model on Hybrid FPGA/CPU Computational Components, Proceedings of the 1st Workshop on Embedded Processor Architectures (WEPA) held in conjunction with the International Symposium on Computer Architecture, February, 2004, Madrid, Spain. File:Wepa.pdf | Andrews, D., Niehaus, D., and Ashenden, P., Programming Models for Hybrid FPGA/CPU Computational Components, IEEE Computer, January 2004. File:Computer.pdf | Michael Finley, Hardware/Software Codesign: Thread Manager, Master’s Thesis at the University of Kansas (December, 2004). Thesis and presentation slides | . ",
    "url": "/publications/#2004",
    
    "relUrl": "/publications/#2004"
  },"146": {
    "doc": "Publications",
    "title": "2003",
    "content": ". | Niehaus, D. , Andrews, D., Using the Multi-Threaded Computation Model as a Unifying Framework for Hardware-Software Co-Design and Implementation, Proceedings of the 9th International Workshop on Object-oriented Real-time Dependable Systems (WORDS 2003). File:Ku-words.pdf | David Andrews and Douglas Niehaus, Architectural Frameworks for MPP System on a Chip, Proceedings of the Third Workshop on Massively Parallel Processing (MPP), April 2003, Nice, France. File:Mpp.pdf | . ",
    "url": "/publications/#2003",
    
    "relUrl": "/publications/#2003"
  },"147": {
    "doc": "Schedule",
    "title": "Weekly Schedule",
    "content": " ",
    "url": "/classes/computer-architecture/schedule/#weekly-schedule",
    
    "relUrl": "/classes/computer-architecture/schedule/#weekly-schedule"
  },"148": {
    "doc": "Schedule",
    "title": "Introduction to Java",
    "content": "Sep 28 Java &amp; Git 1.1 Sep 29 SectionIntro to Java Solution Sep 30 Variables &amp; Objects 1.2, 2.1 Oct 1 Lab Intro to Java Oct 2 Tracing, IntLists, &amp; Recursion 2.1 HW 1 due ",
    "url": "/classes/computer-architecture/schedule/#introduction-to-java",
    
    "relUrl": "/classes/computer-architecture/schedule/#introduction-to-java"
  },"149": {
    "doc": "Schedule",
    "title": "Basic Data Structures",
    "content": "Oct 5 Linked Lists &amp; Encapsulation 3.1, 2.2, 2.3 Oct 6 SectionLinked Lists Solution Oct 7 Resizing Arrays 2.4, 2.5 Oct 8 Lab Resizing Arrays Oct 9 Runtime Analysis 8.1, 8.2, 8.3, 8.4 HW 2 due ",
    "url": "/classes/computer-architecture/schedule/#basic-data-structures",
    
    "relUrl": "/classes/computer-architecture/schedule/#basic-data-structures"
  },"150": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": " ",
    "url": "/classes/computer-architecture/schedule/",
    
    "relUrl": "/classes/computer-architecture/schedule/"
  },"151": {
    "doc": "Schedule",
    "title": "Weekly Schedule",
    "content": "| Week 1 8/21-8/25 | Lecture Topic | Assignment | . | Mon | Course Introduction | Read ch 1.1, 2.1,2.2: download Vivado 2019.1 | . | Weds | Characteristics of Embedded Systems | Read Ch 2.8 | . | Fri | Basic Software Techniques:Pointer Review | Homework #1 Assigned | . | Week 2 8/28-9/1 | Lecture Topic | Assignment | . | Mon | Basic Software Techniques:Bit twiddling in C | Read the GPIO data sheet | . | Weds | Parallel Input/Output | Read the GPIO data sheet | . | Fri | More on Basic Software Techniques |   | . | Week 3 9/4-9/8 | Lecture Topic | Assignment | . | Mon | Labor Day |   | . | Weds | Lab 1 makeup |   | . | Fri | Tips on Vivado |   | . | Week 4 9/11-9/15 | Lecture Topic | Assignment | . | Mon | Asynchronous Communications |   | . | Weds | Asynchronous Communications |   | . | Fri | UART-Lite |   | . | Week 5 9/18-9/22 | Lecture Topic | Assignment | . | Mon | Time Measurement:Polling |   | . | Weds | Waveform Generation:PWM |   | . | Fri | Waveform Generation:PWM |   | . | Week 6 9/25-9/29 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 7 10/2-10/6 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 8 10/9-10/13 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds | Midterm Review |   | . | Fri | Midterm Exam |   | . | Week 9 10/16-10/20 | Lecture Topic | Assignment | . | Mon | Fall Break |   | . | Weds |   |   | . | Fri |   |   | . | Week 10 10/23-10/27 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 11 10/30-11/3 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 12 11/6-11/10 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 13 11/13-11/17 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 14 11/20-11/24 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds | Thanksgiving Break! |   | . | Fri | Thanksgiving Break! |   | . | Week 15 11/27-12/1 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds |   |   | . | Fri |   |   | . | Week 16 12/4-12/8 | Lecture Topic | Assignment | . | Mon |   |   | . | Weds | Semester Review | All Materials Due Before Friday | . | Fri | Reading Day |   | . | Final 12/8 | **3:00pm - 5pm ** | Final is not comprehensive | . ",
    "url": "/classes/embedded-systems/schedule/#weekly-schedule",
    
    "relUrl": "/classes/embedded-systems/schedule/#weekly-schedule"
  },"152": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": " ",
    "url": "/classes/embedded-systems/schedule/",
    
    "relUrl": "/classes/embedded-systems/schedule/"
  },"153": {
    "doc": "Schedule",
    "title": "Weekly Schedule",
    "content": ". | 9:00 AM | 9:30 AM | 10:00 AM | 10:30 AM | 11:00 AM | 11:30 AM | 12:00 PM | 12:30 PM | 1:00 PM | 1:30 PM | 2:00 PM | 2:30 PM | 3:00 PM | 3:30 PM | 4:00 PM | 4:30 PM | 5:00 PM | 5:30 PM | . | ",
    "url": "/schedule/#weekly-schedule",
    
    "relUrl": "/schedule/#weekly-schedule"
  },"154": {
    "doc": "Schedule",
    "title": "Monday",
    "content": ". | Lecture 9:30 AM–10:30 AM 150 Wheeler | Section 11:30 AM–12:30 PM 310 Soda | Office Hours 12:30 PM–2:00 PM 271 Soda | . | ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"155": {
    "doc": "Schedule",
    "title": "Tuesday",
    "content": "| ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"156": {
    "doc": "Schedule",
    "title": "Wednesday",
    "content": ". | Lecture 9:30 AM–10:30 AM 150 Wheeler | Section 11:30 AM–12:30 PM 310 Soda | Office Hours 12:30 PM–2:00 PM 271 Soda | . | ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"157": {
    "doc": "Schedule",
    "title": "Thursday",
    "content": "| ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"158": {
    "doc": "Schedule",
    "title": "Friday",
    "content": ". | Lecture 9:30 AM–10:30 AM 150 Wheeler | Section 11:30 AM–12:30 PM 310 Soda | Office Hours 12:30 PM–2:00 PM 271 Soda | . | . ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"159": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": " ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"160": {
    "doc": "Staff",
    "title": "Staff",
    "content": "Staff information is stored in the _staffers directory and rendered according to the layout file, _layouts/staffer.html. ",
    "url": "/staff/",
    
    "relUrl": "/staff/"
  },"161": {
    "doc": "Staff",
    "title": "Instructors",
    "content": " ",
    "url": "/staff/#instructors",
    
    "relUrl": "/staff/#instructors"
  },"162": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": " ",
    "url": "/classes/computer-architecture/syllabus/",
    
    "relUrl": "/classes/computer-architecture/syllabus/"
  },"163": {
    "doc": "Syllabus",
    "title": "Overview",
    "content": "This course introduces students to the design and analysis of computer systems that interact with the built environment. Applications of these systems impact nearly every aspect of modern life. Examples include cell phones, smartwatches, home monitoring systems, medical devices, autonomous (and non-autonomous) vehicles, UAVs, airplanes, submarines and space vehicles. As part of the course, students will learn about architecture, software, and hardware aspects of embedded systems development. The design of systems is a complex multi-objective optimization task, and students will develop an understanding of how to work within the parameters given to meet constraints (e.g. real-time deadlines, memory, disk, connectivity, power, etc.). ",
    "url": "/classes/embedded-systems/syllabus/#overview",
    
    "relUrl": "/classes/embedded-systems/syllabus/#overview"
  },"164": {
    "doc": "Syllabus",
    "title": "Textbook",
    "content": ". | Frank Vahid, Tony Givargis, Bailey Miller, Programming Embedded Systems, Zybook. | (Optional) Marilyn Wolf, Embedded System Interfacing: Design for the Internet-of-Things (IoT) and Cyber-Physical Systems (CPS), Elsevier; 2019 Edition. | . ",
    "url": "/classes/embedded-systems/syllabus/#textbook",
    
    "relUrl": "/classes/embedded-systems/syllabus/#textbook"
  },"165": {
    "doc": "Syllabus",
    "title": "Lecture Topics",
    "content": "| Topic | Coverage | . | Characteristics of Embedded Systems | 1 week | . | Basic Software Techniques | 2 weeks | . | Parallel Input and Output | 1 week | . | Asynchronous and Synchronous Serial Communications | 1 week | . | Polling, Interrupts, Timers | 3 week | . | Data Acquisition, Sampling Theory and A/D Convertors | 2 weeks | . | Real Time Programming Models and Requirements | 2 weeks | . | Real Time Scheduling | 1 week | . | RTOS’s (FreeRTOS) | 2 weeks | . | Selected topics (Trends, OS and Compiler for ES, etc …) | 1 week | . ",
    "url": "/classes/embedded-systems/syllabus/#lecture-topics",
    
    "relUrl": "/classes/embedded-systems/syllabus/#lecture-topics"
  },"166": {
    "doc": "Syllabus",
    "title": "Laboratory Component",
    "content": "This class has a laboratory component allowing students to gain hands-on experience designing,building, and testing an embedded system. Laboratories throughout the semester build towards a final class project. The final project is at the discretion of the Instruction and may vary from semester to semester. Most recently students build an autonomous car controlled by an SoC implemented as soft IP in an FPGA running FreeRTOS using multiple sensors to control servo motors for the car to follow a track and avoid obstacles. ",
    "url": "/classes/embedded-systems/syllabus/#laboratory-component",
    
    "relUrl": "/classes/embedded-systems/syllabus/#laboratory-component"
  },"167": {
    "doc": "Syllabus",
    "title": "Learning Outcomes",
    "content": ". | Describe the characteristics of embedded systems as well as the challenges related with their design | Summarize the key components of an embedded system as well as their interactions | Identify and formalize design goals (cost, power, time-to-market, etc …) | Choose the right model and tools for capturing and analyze complex embedded systems | Conduct a project in team and present the results in a fundamental way | Evaluate a produced design and identify where improvements to the design could be made to improve one or more design parameters | . ",
    "url": "/classes/embedded-systems/syllabus/#learning-outcomes",
    
    "relUrl": "/classes/embedded-systems/syllabus/#learning-outcomes"
  },"168": {
    "doc": "Syllabus",
    "title": "Grading",
    "content": "| Activity | Weight | . | 2 Exams | 30% each | . | Labs | 20% | . | Homework | 10% | . Grading will be on a 90%-80%-70%-60% scale. Curving may be applied based on course average. ",
    "url": "/classes/embedded-systems/syllabus/#grading",
    
    "relUrl": "/classes/embedded-systems/syllabus/#grading"
  },"169": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": " ",
    "url": "/classes/embedded-systems/syllabus/",
    
    "relUrl": "/classes/embedded-systems/syllabus/"
  }
}
