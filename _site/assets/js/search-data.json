{"0": {
    "doc": "Just the Class",
    "title": "Just the Class",
    "content": "# Just the Class Just the Class is a GitHub Pages template developed for the purpose of quickly deploying course websites. In addition to serving plain web pages and files, it provides a boilerplate for: - [announcements](/announcements/), - a [course calendar](/calendar/), - a [staff](/staff/) page, - and a weekly [schedule](/schedule/). Just the Class is a template that extends the popular [Just the Docs](https://github.com/just-the-docs/just-the-docs) theme, which provides a robust and thoroughly-tested foundation for your website. Just the Docs include features such as: - automatic [navigation structure](https://just-the-docs.github.io/just-the-docs/docs/navigation-structure/), - instant, full-text [search](https://just-the-docs.github.io/just-the-docs/docs/search/) and page indexing, - and a set of [UI components](https://just-the-docs.github.io/just-the-docs/docs/ui-components) and authoring [utilities](https://just-the-docs.github.io/just-the-docs/docs/utilities). ## Getting Started Getting started with Just the Class is simple. 1. Create a [new repository based on Just the Class](https://github.com/kevinlin1/just-the-class/generate). 1. Update `_config.yml` and `README.md` with your course information. [Be sure to update the url and baseurl](https://mademistakes.com/mastering-jekyll/site-url-baseurl/). 1. Configure a [publishing source for GitHub Pages](https://help.github.com/en/articles/configuring-a-publishing-source-for-github-pages). Your course website is now live! 1. Edit and create `.md` [Markdown files](https://guides.github.com/features/mastering-markdown/) to add more content pages. Just the Class has been used by instructors at Stanford University ([CS 161](https://stanford-cs161.github.io/winter2021/)), UC Berkeley ([Data 100](https://ds100.org/fa21/)), UC Santa Barbara ([CSW8](https://ucsb-csw8.github.io/s22/)), Northeastern University ([CS4530/5500](https://neu-se.github.io/CS4530-CS5500-Spring-2021/)), and Carnegie Mellon University ([17-450/17-950](https://cmu-crafting-software.github.io/)). Share your course website and find more examples in the [show and tell discussion](https://github.com/kevinlin1/just-the-class/discussions/categories/show-and-tell)! ### Local development environment Just the Class requires no special Jekyll plugins and can run on GitHub Pages' standard Jekyll compiler. To setup a local development environment, clone your template repository and follow the GitHub Docs on [Testing your GitHub Pages site locally with Jekyll](https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/testing-your-github-pages-site-locally-with-jekyll). ",
    "url": "/",
    
    "relUrl": "/"
  },"1": {
    "doc": "About",
    "title": "About",
    "content": "# About {:.no_toc} ## {: .no_toc .text-delta } 1. TOC {:toc} --- ## About Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Aliquam ut porttitor leo a diam. Erat nam at lectus urna duis convallis convallis tellus id. Pellentesque elit eget gravida cum sociis natoque penatibus et magnis. Ultrices vitae auctor eu augue ut lectus arcu. Morbi tristique senectus et netus et malesuada. Turpis tincidunt id aliquet risus feugiat in ante. Consequat interdum varius sit amet mattis vulputate enim nulla. Felis eget nunc lobortis mattis aliquam. Eu non diam phasellus vestibulum lorem sed risus. A condimentum vitae sapien pellentesque habitant morbi tristique. Orci dapibus ultrices in iaculis nunc sed augue lacus viverra. Proin sagittis nisl rhoncus mattis rhoncus urna neque. Dictum varius duis at consectetur lorem donec massa sapien. Blandit cursus risus at ultrices mi tempus imperdiet. Laoreet sit amet cursus sit amet dictum sit amet justo. Felis eget nunc lobortis mattis aliquam faucibus. Nam aliquam sem et tortor consequat. ## Lecture Tempus iaculis urna id volutpat lacus laoreet non curabitur gravida. Vulputate dignissim suspendisse in est ante in. Massa vitae tortor condimentum lacinia quis vel. Gravida neque convallis a cras semper auctor. Pellentesque eu tincidunt tortor aliquam nulla. Quam adipiscing vitae proin sagittis nisl rhoncus mattis rhoncus urna. Sit amet purus gravida quis blandit turpis cursus in. Porttitor leo a diam sollicitudin tempor. Vel facilisis volutpat est velit egestas dui id ornare. Cum sociis natoque penatibus et magnis. Tristique magna sit amet purus gravida. Nibh sit amet commodo nulla facilisi nullam vehicula. Aenean vel elit scelerisque mauris pellentesque pulvinar pellentesque. Id semper risus in hendrerit gravida. Sit amet justo donec enim diam vulputate ut pharetra sit. Vitae justo eget magna fermentum. Tellus in metus vulputate eu. Pellentesque id nibh tortor id aliquet lectus proin nibh nisl. Etiam erat velit scelerisque in dictum non consectetur a erat. Pellentesque eu tincidunt tortor aliquam nulla. ## Resources Lacus viverra vitae congue eu. Suspendisse in est ante in nibh mauris cursus mattis. Nisl vel pretium lectus quam id leo in. Euismod lacinia at quis risus sed vulputate odio. Non enim praesent elementum facilisis. Aliquet sagittis id consectetur purus ut faucibus pulvinar elementum integer. Id interdum velit laoreet id donec ultrices tincidunt arcu. Urna molestie at elementum eu facilisis sed odio. Auctor urna nunc id cursus metus aliquam eleifend. Volutpat commodo sed egestas egestas fringilla phasellus. Libero nunc consequat interdum varius sit amet mattis. Imperdiet nulla malesuada pellentesque elit eget gravida cum sociis natoque. Tortor vitae purus faucibus ornare suspendisse. Auctor elit sed vulputate mi. ## Assignments Vehicula ipsum a arcu cursus vitae congue. Etiam dignissim diam quis enim lobortis scelerisque fermentum dui. Risus sed vulputate odio ut enim blandit. Aliquam id diam maecenas ultricies mi eget. Id consectetur purus ut faucibus pulvinar elementum integer enim neque. Eget mi proin sed libero enim sed faucibus. Sem integer vitae justo eget magna fermentum iaculis. In mollis nunc sed id semper risus in. Sit amet risus nullam eget felis eget. Mattis ullamcorper velit sed ullamcorper morbi tincidunt ornare massa eget. Nascetur ridiculus mus mauris vitae ultricies leo integer malesuada. Porta non pulvinar neque laoreet suspendisse interdum consectetur libero id. At varius vel pharetra vel turpis nunc eget. Scelerisque purus semper eget duis at tellus. ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"2": {
    "doc": "Announcements",
    "title": "Announcements",
    "content": "# Announcements Announcements are stored in the `_announcements` directory and rendered according to the layout file, `_layouts/announcement.html`. {% assign announcements = site.announcements | reverse %} {% for announcement in announcements %} {{ announcement }} {% endfor %} ",
    "url": "/announcements/",
    
    "relUrl": "/announcements/"
  },"3": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": "# Calendar {% for module in site.modules %} {{ module }} {% endfor %} ",
    "url": "/calendar/",
    
    "relUrl": "/calendar/"
  },"4": {
    "doc": "PiCaSO",
    "title": "PiCaSO",
    "content": "# PiCaSO ",
    "url": "/projects/picaso/",
    
    "relUrl": "/projects/picaso/"
  },"5": {
    "doc": "Projects",
    "title": "Projects",
    "content": "# Projects {:.no_toc} ## Table Of Contents {:.no_toc .text-delta} 1. TOC {:toc} --- # Current Projects ## [PiCaSO](picaso) Processor-in-Memory (PIM) architectures are highly suitable for data-intensive applications like machine learning. While there exists several proposals for custom PIM blocks for FPGAs, they are not currently available in the commodity FPGAs. PiCaSO is a fast and scalable Processor-in-Memory (PIM) overlay architecture. PiCaSO serves as a viable solution for emulating PIM on existing FPGAs, delivering comparable performance to dedicated custom implementations. Development of PiCaSO is supported by National Science Foundation under Grant No. 1955820. Check out PiCaSO on Github. # Old Projects ## Heterogeneous Extensible MultiProcessor Systems (HEMPS) The goal of the Heterogeneous Extensible Multiprocessor System (HEMPS) is to provide a programming model for heterogeneous platforms containing mixes of processors, processors with statically attached accelerators, and processors with dynamic accelerators capable of online reconfiguration. As a result, HEMPS incorporates a runtime system that profiles and adaptively partitions a high-level application onto available heterogeneous resources. ## Synthesis Free Approach to Domain-Specific Accelerator Design The world of software development has the notion of just-in-time compilation, run time binary translation, and language interpretation. There are no such equivalences to increase the productivity or portability of creating new hardware components. Creating a new hardware component requires running through a very time consuming synthesis process. Whereas even re-compiling code can be done in seconds, synthesis takes hours. As we move towards chip heterogeneous multiprocessor systems with more customized accelerator components we need a new flow that eliminates the need to synthesize for every change. We need a new flow that allows software as well as hardware developers to quickly assemble custom hardware accelerators using compilation and run time interpretation techniques. The fundamental question this project seeks to answer is: can software compilation or run time interpretation equivalences replace traditional hardware synthesis for creating custom accelerators? ## Self Assembly of MPSoPCs When we talk about putting the ability to create a complete MPSoPC at your fingertips, we mean the whole ball of wax; a complete integrated hardware architecture and protocol stack! You can easily create SMP and NUMA Multiprocessor Systems on Chip Architectures using a menu-driven web interface in the Cloud. The produced MPSoPC contains Hthreads which is a Pthreads compliant run time system. You can write Pthreads programs using our compiler/linker, download onto you MPCoPC and run ! ## Heterogeneous Multi- and Many-Core Systems Creating heterogeneous SoCs in which each processor has uniform access to operating system services. This project leverages the existing HThreads architecture to allow heterogeneous processors (processors with different ISAs) to communicate and synchronize using a uniform set of OS APIs. Uniform sets of abstractions allow applications to be developed, compiled, and deployed on heterogeneous systems almost as easily as if they were a homogeneous system. Learn more about Heterogeneous_Threads. ## Cache Design for Solid-State Drives A solid-state drive (SSD) is a data storage device that uses solid-state memory to store persistent data with the intention of providing access in the same manner of a traditional block i/o hard disk drive. The de facto memory used in SSDs currently is flash memory. SSDs are potentially more robust than hard disk drives due to the fact that there is no internal moving parts. Further it provides more data access parallelism since multiple flash packages can be accessed simultaneously. However, the flash-based SSD has its own disadvantages as well. First, the write performance is much lower than the read performance. Second, each flash cell can sustain a limited number of writes. This project is intended to address these two issues by proposing an on-board cache for SSDs. Various cache algorithms are to be investigated. A new automatic periodic update (APU) feature is proposed. Results show that the on-board cache can significantly reduce the access latency to SSDs and improve the lifetime of the drives as well. ## Programming Models and Runtime Support for GPUs Graphics Processing Units (GPUs) are ubiquitous in modern computers. Modern GPUs are very efficient at manipulating computer graphics, and their highly parallel structure makes them more effective than general-purpose CPUs for algorithms where processing of large blocks of data is done in parallel. One of the biggest overhead to use GPUs is the data communication between host CPU and GPU. This overhead can be hidden by overlapping the computation and communication of different GPU contexts. A programming model is proposed to efficiently merge the kernel functions in a multithreaded application into a single context to improve the performance as well as the device occupancy. ## Hybridthreads Hthreads is a computation platform built on top of standard field-programmable gate arrays (FPGAs). This platform is designed as a hardware/software co-designed operating system along with a set of APIs which provide access to the operating system to both hardware and software components. The APIs of hthreads are uniform in policy for both software and hardware threads, although the interfaces used by the two type of threads differ in mechanism. The software thread interface (SWTI) is for use by software components. This interface is designed as a lightweight wrapper around the hardware-based Hthreads operating system and so provides very low-overhead operation. The hardware thread interface (HWTI) is for use by hardware components. This interface is designed in VHDL as a black box hardware component which is capable of communicating with the Hthreads operating system. This design provides seamless integration between hardware components and software components because both the software interface and the hardware interface provide uniform access to the same operating system APIs. This functionality is provided at a very low cost to efficiency because of Hthreads unique hardware based operating system. Learn more about hybridthreads. Learn how to start using hybridthreads. ## FSMLanguage FSMLanguage is a domain-specific language (DSL) for describing finite-state machines. The language was developed in order to create a way for programmers to develop re-targetable representations of FSMs. The FSMLanguage compiler is capable of producing both software- and hardware-implementations of FSMLanguage programs. Both implementation types remain compatible with one another as the communication abstractions that are built in to FSMLanguage are able to cross the hardware/software boundary. Learn more about FSMLanguage. ## Energy Efficiency of MPSoPCs Designing new architecture for Hhthreads to improve the energy efficiency but not compromise any performance. To investigate this topic, the research on dynamic power based on Hthreads OS is start. Lean more about the Energy Efficiency of MPSoPCs . ## Hybridthread Compiler The HybridThread compiler is designed to allow programmers to develop hardware/software co-designed systems from a single, high-level source language. Learn more about the hybridthread compiler. Hog ARray Processor We are interested in developing a co-processor that can handle SIMD operations without the need to develop a custom compiler. To achieve this function the SIMD instructions for the co-processor are a mix of MicroBlaze and custom instructions that are all generated by the standard MicroBlaze compiler in XST with some custom libraries. ## Application-Specific Embedded Manycore System Generation using OpenCL Using OpenCL The capacity of Field Programmable Gate-Arrays (FPGAs) is approaching 1 million LUTs. With this capacity, it is possible to create a complete multiprocessor system on a single FPGA device. The traditional approach to designing a system-on-chip is to use the specific tools from the chip vendors. However, this approach generally requires hardware design expertise and lacks the portability. An alternative approach is to generate systems directly from applications written in high-level languages, such as OpenCL. OpenCL is a framework to design parallel applications on multicore/manycore platforms. Both the data parallelism and the architectural hierarchy are explicitly exposed in an OpenCL application. This project focuses on (1) developing a complete flow to generate a multiprocessor system given an OpenCL application, and (2) investigating the high-level synthesis techniques to realize the optimal processor architecture and interconnect infrastructure of the system. ",
    "url": "/projects/",
    
    "relUrl": "/projects/"
  },"6": {
    "doc": "CSCE 4213 Computer Architecture",
    "title": "CSCE 4213 Computer Architecture",
    "content": "# CSCE 4213 Computer Architecture {:.no_toc} ## {: .no_toc .text-delta } 1. Links {:toc} --- ## Introduction Welcome to CSCE 4213 Computer Architecture. It is truly an exciting time to study computer architecture as we are about to engage in a major change in how computers are built ! In this class you will first become familiar with how to measure performance and understand current trends in how the industry is building computers. Then, you will study many of the important historical techniques that the computer industry has developed over the last 20 years for executing multiple instructions concurrently and out of order within scalar cores. This is followed by studying how to combine multiple cores into a multiprocessor system. This will include cache coherency and architecture support for atomic operations. Finally you will study architectures used to accelerate machine learning applications. ## Catalog Description The architecture of modern scalar and parallel computing systems. Techniques for dynamic instruction scheduling, branch prediction, instruction level parallelism, shared and distributed memory multiprocessor systems, array processors, and memory hierarchies. Prerequisite CSCE 2214 ## Textbook Computer Architecture. A Quantitative Approach. Sixth Edition, by David A. Patterson and John L. Hennessy, Morgan Kaufmann Publishers, Inc., 2019. ## Topics Covered - Technology trends and Performance Evaluation - Instruction Level parallelism - Branch Prediction, Dynamic Scheduling, Hardware Speculation - Limitations of Instruction-Level Parallelism - Multithreading and Thread Level Parallelism - Symmetric Shared-Memory Architectures Performance and Synchronization - Distributed Shared Memory and Directory Based Coherence - Vector Processors - SIMD Extensions - Graphics Processor Units (GPUs) - Memory Hierarchies ## Class/Assigned Readings - Lecture meets M/W/F 3:05 - 3:55 in Blackboard - Readings posted for a week represent the material that will be covered for that week. Part of your preparation for the week is to have performed a first reading of the material in order to familiarize yourself with the topics that will be covered. ## Course Outcomes - Knowledge of the history and social impact of high performance computing - Knowledge of Computer Architecture - Ability to apply knowledge of digital logic and computer organization to the design of a computer system - Students are required to apply mathematics in the evaluation of the performance of a computer - Students are required to understand the architecture of a computer system ## Lectures [Weekly Schedule](./schedule) ## Homework [Weekly Schedule](./schedule) ",
    "url": "/classes/computer-architecture/",
    
    "relUrl": "/classes/computer-architecture/"
  },"7": {
    "doc": "Advanced Computer Architecture",
    "title": "Advanced Computer Architecture",
    "content": " ",
    "url": "/classes/advanced-computer-architecture/",
    
    "relUrl": "/classes/advanced-computer-architecture/"
  },"8": {
    "doc": "Lab 2",
    "title": "Lab 2",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab2/",
    
    "relUrl": "/classes/embedded-systems/labs/lab2/"
  },"9": {
    "doc": "Lab 5",
    "title": "Lab 5",
    "content": "# Lab 5: Interrupt Driven MicroBlaze System The goal of these labs is to become familiar with the idea of interrupt-based processing techniques using the MicroBlaze processor. A base system will be built that utilizes an interrupt controller to allow for multiple interrupt sources along with a set of interrupt sources. The interrupt sources will include a timer as well as a software interrupt. After understanding what an interrupt does and how to properly implement them, we will then return to the bike trail crossing project and modify the design to use interrupts. You covered interrupts in class exactly as they work with the MicroBlaze. You can refer to Dr. Andrews' slides from lecture if you have conceptual misunderstandings. ## Lab Directions For this lab, you will explore the use of software interrupts and timer interrupts in example programs and then you will modify the design of the bike trail traffic crossing signal to rely on interrupts rather than polling to see if the timer has completed. To keep the design consistent between all students for grading purposes, the final design should contain/do the following: * Display a green (RGB) output on the display when no bikers or walkers are trying to cross the street. * Display a flashing red output on the display immediately after any of the tactile push buttons are pressed. * This stage should last a total of 6 seconds * The amount of time the LED should be on or off in the flashing stage should be 0.5 seconds. (e.g.: 0.5s on, 0.5s off, 0.5s on, ...) * If the button is pressed during this stage, the 6 second timer should reset back to zero and the LEDs should blink for another 6 seconds. This is the only stage where this happens * After the LEDs have flashed red for 6 seconds, the traffic signal should display the red LEDs for exactly 4 seconds * After the solid red stage, the red LEDs should then flash red again for 6 seconds. A button press here should not affect nor reset any stage countdown timer. ## Background The MicroBlaze processor has only a single interrupt port, called the Interrupt port. This port is a 1-bit signal that can be configured to be either edge- or level-triggered. A multiplexer must be used in order to create a MicroBlazebased system that has multiple interrupt sources. A multiplexer built specifically to handle interrupt sources is often referred to as an interrupt controller, or often, a programmable interrupt controller (PIC). The following diagram demonstrates how an interrupt controller is used to multiplex many interrupt sources onto a single interrupt request line. Interrupt.jpg In this type of situation the processor must be able to determine which interrupts have fired and need servicing. Most interrupt controllers contains registers that allow a processor to query the following: * Which interrupts are enabled? * Interrupt Enable Register (IER). * Which interrupts have fired and need servicing? * Interrupt Service Register (ISR). * Which interrupts need to be cleared? * Interrupt Acknowledge Register (IAR). When the processor receives an interrupt, it must first look at the interrupt service register (ISR) to figure out which interrupts need to be serviced. Each bit in the ISR represents an individual interrupt source. If a bit X in the ISR is '1' then interrupt source X needs to be serviced. If bit X in the ISR is '0' then the interrupt has not fired and does not need to be serviced. After servicing each active interrupt, the processor must then clear the interrupt as well as its source. The ordering of this operation is extremely important due to the fact that clearing an interrupt before clearing its source will result in apparent multiple interrupt events for a single source event. Therefore it is pertinent to always clear an interrupt at its source, and then proceed until you have cleared the interrupt at the PIC and at the processor. If interrupts are cleared incorrectly then “bad” situations can occur. For example: 1. Interrupt0 occurs. * Bit0 in the ISR is set to 1. 2. CPU receives an interrupt and then CPU jumps into its interrupt handler routine. 3. CPU checks Bit0 in the ISR. * CPU then services the interrupt, but forgets to clear Bit 0!!!! 4. The CPU now returns from its interrupt handler routine to continue “normal” processing. 5. OH NO, BUT WAIT!!!! Bit0 has never been cleared, so the CPU's interrupt line is still asserted!!!! * The CPU jumps right back into the interrupt handler routine, even though no new interrupts have occurred!!!! In order to correct the situation described above, the interrupt handler should clear the interrupt at its source, and then at the PIC in step (3). Clearing an interrupt at the PIC can be done by writing a '1' to the bit of interest to the PIC's interrupt acknowledge register (IAR). ## Project Assignment **Before Executing the Lab:** I recommend looking through the AXI Timer [Documentation](https://www.xilinx.com/support/documentation/ip_documentation/axi_timer/v2_0/pg079-axi-timer.pdf) and AXI Interrupt Controller [Documentation](https://www.xilinx.com/support/documentation/ip_documentation/axi_intc/v4_1/pg099-axiintc.pdf) documents at their respective links to better understand the modules we will be working with in this lab. It is also worth mentioning that C documentation for interacting with these modules is available within SDK by looking at the system.mss file typically located within a project with the \"_bsp\" suffix. **Hardware:** In lab 4, we made modifications to the block design in Vivado to enable future interrupt capability; however, there was a slight oversight in the instructions of that design. Because this is a complex lab with a lot of new C code to comprehend, I won't make the modification of the block design a part of this lab and will supply a working bitstream file and example set of projects within a SDK workspace folder. This folder can be found here (https://github.com/zackheil/teaching-CSCE4114-EmbeddedSystems). To use the project, download the linked repository and extract the folder \"lab5.sdk\" to a usable space on your computer. From here, open SDK 2016.4, and when the prompt appears, choose the lab5.sdk folder to be the workspace location. This should open the SDK project with the included bitstream that supports interrupt functionality as well as a few example projects. **Software:** Now, you must write software to enable the features of the newly created interrupt-based system. This involves writing initialization code that will enable interrupt-related functions on all of the interrupt sources, the interrupt controller, and the MicroBlaze processor. Additionally, an interrupt handler routine will be written to handle interrupts when they occur. Conceptually, an interrupt handler routine can be thought of as a function that can be called at anytime from anywhere (if interrupts are enabled). This implies that an interrupt handler routine must not have any effect on the state of the CPU, otherwise, program behavior could be seriously altered by the assertion of an interrupt An Example: Consider a program controlling a stoplight puts a counter value in r20 to represent how long to keep the yellow light lit, and let us also say that a “rogue” interrupt handler routine always sets r20 to 0x0000_0000. The program would not be able to detect when this happens due to the fact that an ISR can be invoked at any time interrupts are enabled. This would essentially cause the stoplight to go from green to red instantly, which could result in adverse real-world effects. On the other hand, an interrupt handler routine is allowed to change values in memory (i.e. variables, device registers, etc.) as this does not have any side-effects on the actual state of the CPU. Thus, an interrupt handler routine must save all pertinent CPU state upon an interrupt, and must restore the CPU state after servicing needed interrupts. In the case of the MicroBlaze processor, this is handled by the “main” interrupt handler routine; which is a function that “wraps” up the user’s interrupt handler routine in such a way that the user does not have to worry about saving CPU state. This requires a programmer to “register” their interrupt handler routine so that the “main” interrupt handler knows which user-level handler to call upon invocation of an interrupt. Essentially, registration just involves putting the address of the user-level function in a place known by the “main” interrupt handler. This place is known as the interrupt vector table. Interrupts on the MicroBlaze can be enabled/disabled by interacting with the MSR register. The MSR register is a special purpose register, so the MTS and MFS instructions are needed to read/write the MSR register. The basic order of operations for your software should be the following: * **Main program:** * Setup interrupts * Register a handler * Enable interrupts on all sources. * Setup the timer to generate a periodic interrupt. * This is done by setting bits in the timer Control and Status Register * In our case there a few hints I will give you, but the rest have to be understood and set by you * The timer mode should be set to generate * Enable external generate signal and enable external capture should be set to 0 * For the counter to run load should be a zero, for the counter to Load a value it shouldn't be running * Pulse width modulation should be set to a zero * Enable interrupts on the MicroBlaze. * Enter an infinite loop to print out a global variable, called X. * **Interrupt handler:** * Service each interrupt that has fired. * Do this by incrementing the global variable X. * Clear and service all interrupts that have fired. * Clear them at the source, then the PIC. * Return It's worth noting that all of these steps are required to get interrupts working from the ground up, but some of the functions provided by Xilinx that we will be using actually perform these operations behind the scenes. As you look through some of the examples in the provided SDK project, feel free to explore the source code of the provided functions by right clicking on functions, variables, or definitions and selecting \"Open Declaration\" to see where these calls are actually made. ## Project Instructions * Start off by downloading and extracting the lab5.sdk folder from the Github link above. * Open SDK and set the workspace to the extracted folder to get access to the example projects and the bitstream. * From here, load the bitstream on to the Arty board. Before moving on to timer interrupts, let's look how we can trigger an interrupt using software with a provided example. * Open up the project \"xintc_low_level_example_1\" from the project explorer pane and locate the C file in the src directory. Look through the code and inspect what it will be doing before attempting to run it. * Open up a serial terminal monitor to the correct COM port like in earlier labs. * In the Project explorer, highlight the current project's root folder (has \"xintc_low_level_example_1\" in it) and then click on the debug icon dropdown in the toolbar beside the usual run button that is pressed to execute code on the Arty. Choose \"debug as\" and \"run on system hardware\". The code will stop as soon as it enters the main function. * Step through the code to see what each step is doing and how it operates. At some point in execution, you will see a function call to XIntc_SimulateIntr which will set the ISR register and will seemingly reroute the execution to the DeviceDriverHandler function at the bottom. * This function will write to the console that an interrupt has occurred and then will resume execution where it left off. * Now that we have seen an example of how the ISR can be set with the simulate interrupt function that Xilinx has, let's now use the timer to trigger the interrupt. Open up the \"timer_interrupt_example_zheil\" project. This demonstrates a useful example where the Microblaze is just trying to execute a while loop where it outputs a counter value to the LEDs, yet is constantly interrupted to update the counter that the LED is outputting. * Observe the extra steps to set up the timer interrupt and the options that were previously set using direct register setting operations with pointers. * Also observe how the functions for setting up both the interrupt controller and the timer were extracted into the main function in a linear format so that the instructions could be seen without the need to jump into the function calls. In your implementation of the timer interrupts, take these operations and group them into meaningful function calls so your code isn't as linear as this demonstration. * Highlight the project root in the project explorer and run this example. Note that it is a simple binary counter that increments every half second. * Take some time to really understand this code, then create a new project and add the FSM design, but modify the design to use the interrupts instead of relying on polling. Remember that there are stricter grading guidelines for this lab, so be mindful of the timing for each state. ## Pre-Lab Questions * Instead of pre-lab questions this week, I encourage you to please read through this entire lab assignment once and go through the example (commented) programs supplied in the lab5.sdk project. ## References * AXI Timer Documentation (https://www.xilinx.com/support/documentation/ip_documentation/axi_timer/v2_0/pg079-axi-timer.pdf) * AXI Interrupt Controller Documentation (https://www.xilinx.com/support/documentation/ip_documentation/axi_intc/v4_1/pg099-axi-intc.pdf) * File:Xps timer.pdf - XPS Timer documentation * File:Edk interrupts.pdf - Step-by-step instructions on how to create interrupt-based systems (old version but go for it if you'd like) ",
    "url": "/classes/embedded-systems/labs/lab5/",
    
    "relUrl": "/classes/embedded-systems/labs/lab5/"
  },"10": {
    "doc": "Lab 4",
    "title": "Lab 4",
    "content": "# Lab 4: Timers In this lab we will replace the dummy loops inserted in the previous lab to waste a certain amount of time for transitioning the traffic lights with more precise delays provided by the Xilinx AXI Timer core. The timer core contains two 32 bit timers that can be used independently or combined to form either (1) an extended 64 bit timer, or (2) as a Pulse Modulation Wave generator. When used independently each timer can be set up in either (1) Capture, or (2) Generate Mode. There are many different solutions you could implement for this lab using a combination of the two timers. However the simplest solution is to use one timer in the Generate Mode. Before you enter the lab you should read and familiarize yourself with the Timer Core Datasheet. Specifically you should study the data sheet to determine: 1. How to set the control register to configure the timer to be in the generate mode, count down, automatically reload, and disable the generation of an external interrupt. 2. How to set the control register to transfer the value from the load register into the timer and then start the timer. 3. How to poll the status register to identify when the counter transitions down to 0 (i.e 3..2..1..0...reload new count from load register). Hint: You will have to poll a bit (read) and then once the transition is identified, clear the same bit by writing back a 1. ## Project Assignment What follows next is a description of how to use a single timer in the Generate Mode to provide all timing for the Fayetteville Bike crossing. Here is a strategy: 1. Create a delay word to write into the load register to have the timer go off every .5 seconds. 2. When you enter the green light state, turn off the timer 3. When you enter the first flashing red state turn on the timer. You can use the timer going off every .5 seconds as your signal to alternate the red LED (flashing red light changes every .5 seconds). You will have to check for an additional button push which resets the sequence for another 6 seconds from the button push 4. In the solid red state the red light signal will remain on for six seconds. You can time this state by counting the number of .5 second timer events. 5. When you enter the second flashing red sequence the timer will be on and you can use the timer to once again alternate the flashing of the light every .5 seconds. ## Project Directions To start off, we need to add the AXI Timer module to our SoC. This means we need to go back into Vivado and make some modifications to our block design. If you have kept your project organized such that you can modify your original design, then go ahead. If not, you can use the base-soc project that was given back in Lab 2 from here (https://github.com/zackheil/base-soc). It has instructions on how to get started with rebuilding the project from a set of TCL scripts. Note: if you have used this repository/project before, you might have an issue when opening Vivado and running the TCL script with an error saying the directory already exists. This is because the TCL script project is created in the AppData directory in Windows and not a set location like your Desktop or Documents folder. To get rid of this error, you can go to the Windows Start menu, type in %appdata% in the search bar and press enter. A directory called \"Roaming\" will open. From there, navigate to Xilinx\\Vivado\\ to see your temporary projects directory. Take the existing base-soc folder and rename it (e.g.: base-soc-OLD). Now you should be able to open Vivado and run the TCL script again. Now that we have our Vivado project open, we need to go into the block design. Once in the block design, perform the following steps: * On the left side of the block design diagram, there is a mini toolbar with quick actions. Click the \"Add IP\" button and search for the AXI Timer. Double click on it to add it to the block design. * Run the automator from the blue pane that appears at the top. When choosing a clock source to connect to the timer, select the 83.3MHz \"mig_7\" source. * Now, to future-proof the design with interrupt capability, let's add another IP block. Add the \"AXI Interrupt Controller\" to the design in the same fashion as the timer. Run the automation that appears in the banner. * Now we need to manually connect certain I/O to respective ports to create functionality: * Connect the interrupt output on the left side of \"AXI Interrupt Controller\" to the \"Interrupt\" input on the right side of the MicroBlaze block. * Connect the interrupt output on the AXI Timer block to the intr[0:0] input on the AXI Interrupt Controller. * Regenerate the layout and take a screenshot of your design. If you need help later on in the lab, I will need to see this layout to ensure you connected everything correctly. * Now, just like Lab 1, validate the design, generate the HDL wrapper, and create the bitstream. * Export the bitstream and launch SDK from the respective File menu options > Note: if you do not choose to complete the lab in one sitting, and have your project stored in the AppData directory from the TCL loading process, remember **that is where your project is currently stored** when you return to work on the lab later. Now, within SDK, create a new blank Application project for Lab 4. You are eventually going to transfer your FSM design of our bike-crossing light over and use the timer instead of the delay function previously created. Before you do this though, take some time to play around with the Timer module in C code either using the Xilinx API by including \"xtmrctr.h\" as a header file, or by using pointers like how you interface with GPIOs currently. The implementation choice is up to you. If you would like to use the \"xtmrctr.h\" APIs, you can open up the system.mss file included with your project and it will show the peripherals you currently have installed and C examples for how to interface with them with Xilinx APIs. Because this method of controlling the timer is vastly different than using pointers, I will only be able to aid in debugging with the pointer implementations. So if you do not make headway with the API or don't know where to start, choose the pointer method. The base implementation of the pointer method is detailed below: * Locate the addresses for the necessary timer registers detailed in the data sheet in the same way you located the LED and switch registers from the previous labs. * Create a simple C program that implements an LED register set. I recommend the 4 green LEDs just for simplicity. The goal with this mini project is get the timer to function in 1 second intervals to ensure you have everything working before trying to add timers to your existing code base and getting confused. * Before adding any timer code, ensure you can blink an LED or implement a binary counter timer, like the example below: ```C void main(void) { // setup LED direction and variables... int count = 0; while(1) { count++; *ledDataReg = count; // reset the binary counter when it reaches 15. if(count >= 0xF) { count = 0; } } } ``` * You will notice if trying to run the above code that all LEDs will just look like they are lit and not counting at all. This is because the while loop is going super fast. So we can temporarily slow this down with an empty for loop somewhere in the while loop that looks like this: for(int i = 0; i Ask for clarification if you have any questions ## Pre-Lab Questions Your answers should be typed and printed with your name, date and lab number. In addition to answering the following questions, please read the lab assignment on this page and reread Xilinx AXI Timer Datasheet. You may want to write pseudo code if you think you may have trouble finishing the project during your lab time or if you're feeling like a good student. 1. What is the advantage of a timer over the previously used delay_ms function? 2. There are several registers required to interface with the timer module in the SoC, what are those registers and what is their function? 3. When enabling the timer, there is one bit you need to set and one bit you need to clear. What are those two bits? 4. What two methods exist in C for setting the timer parameters? ## References 1. [Xilinx AXI Timer core](https://docs.xilinx.com/v/u/en-US/pg079-axi-timer) ",
    "url": "/classes/embedded-systems/labs/lab4/",
    
    "relUrl": "/classes/embedded-systems/labs/lab4/"
  },"11": {
    "doc": "Lab 6",
    "title": "Lab 6",
    "content": "# Lab 6: Autonomus Vehicle ## Week 1 ### Introduction This first week is devoted to assembling and testing your autonomous robot car. First you and your partner will modify your SoC to include the peripherals necessary for communication with the car sensors. Then you will follow the video instructions to assemble the shadow chassis, which is the base platform for your Arty Bot. Your TA help you through the assembly process. Zip ties and colorful \"engineering\" rubber bands will be able in the lab if you need them ### Lab Instructions 1. Go to [Digilent’s IP (Intellectual Property) repository](https://github.com/Digilent/vivado-library) on GitHub and download their repository of hardware sensor IP and interface definitions. Extract the downloaded zip file and remember the location on your computer where you extracted the files. Ideally, put the extracted folder next to your project folder. 2. Next, download this [GitHub repository](https://github.com/tkamucheka/CSCE4114-ip-repo) and extract it to a separate folder. This repository contains IP necessary for interfacing with the Pmod DHB1 and MAXSONAR hardware sensors. 3. Now let us make some changes to our SoC (System on Chip). Start by opening your project in Vivado. Navigate in the Flow Navigator on the left side to “Open Block Design.” 4. To add our downloaded IP to Vivado, navigate to “Project Settings” to open the project Settings dialog. In the left panel select “IP,” then select the “Repository Manager” tab. Now add the two IP repository folders you downloaded. Select “Apply” and close the dialog. 5. Back in the block design of your SoC. We want to add IP to the SoC for communicating with the external Pmod peripherals. We will add “AXI GPIO,” “Pmod_DHB1”, and “Pmod_Dual_MAXSONAR” IP for communication with the two line detecting light sensors, Pmod MAXSONAR sensor, and Pmod DHB1 motor driver 1. AXI GPIO >> jA - Pmod LS1. Using the “Add IP” button and dialog. Add a new “AXI GPIO” and “Pmod Bridge” IP to your design. DO NOT USE connection automation. Connect the “S_AXI” bus port of the “AXI GPIO” to a slave port on the interconnect. Link to the two GPIO ports on the “AXI GPIO” with the “GPIO_Top_Row” and “GPIO_Bottom_Row” on the Pmod Bridge. Last, in the “Board” window on the left, right-click the “jA” port under Pmod and select “connect component.” In the dialog that appears, find the Pmod bridge you just added and select the “Pmod_out” port as your connection. One more thing, enable interrupts for the “AXI GPIO.” 2. Pmod_Dual_MAXSONAR >> jB - Pmod MAXSONAR. Add the “Pmod_Dual_MAXSONAR” IP and connect it to a Pmod Bridge. You can connect the “Pmod_out” port of the Pmod Bridge to the Pmod port jB. 3. Pmod_DHB1 >> jD – Pmod MAXSONAR. Add the “Pmod_DHB1_v1_0” IP and connect it to the jD Pmod port through a Pmod Bridge 6. Go to \"Address Editor\" window of the block design and and assign memory addresses to the newly added IP. 7. Validate your deign and generate a bitstream 8. Watch the assembly [instruction video](https://www.youtube.com/watch?v=aJRYTqZu5OE) or follow the [instructions given here](https://learn.sparkfun.com/tutorials/assembly-guide-for-redbot-with-shadow-chassis) to assembly the chassis of your robot. ### Assignment Instructions 1. Mount the two IR (infrared) Proximity sensors somewhere on the front of car. Try to mount them as close as possible to the floor. Connect the sensors to one of S1, S2, S3, or S4 pin headers on the Pmod LS1 module. Finally, connect the Pmod LS1 module to the Arty board via the Pmod port you connected the AXI GPIO in the board design. 2. Mount the two Pmod MAXSONAR sensors on the front of the car. Use the provided Pmod extension cables to connect the sensors to the Pmod port where you connected the AXI GPIO in the board design. Connect one sensor to the bottom row of the Pmod port and the other to the top row of the same Pmod port. 3. Connect the Pmod DHB1 to the Arty board via the Pmod port you selected in the board design. Now make the following connections on the Pmod DHB1 module: 1. Connect the left and right motors to the screw terminals J5 and J6. 2. Connect the Hall effect sensors to J7 and J8. The red wire is VCC, black is GND, and white is motor feedback. The motor feedback signal is used to count wheel revolutions using the Hall effect sensors. 3. Connect the AA battery pack to the screw terminal at J4. ### Pre-Lab Take a look at the manuals listed in the references sections 1. [Tang, A. ArtyBot - A two-wheel robotics platform built on the Arty development board. Hackster.io](https://www.hackster.io/atang08/artybot-551478) 2. [Pmod Interface Specification](https://digilent.com/reference/_media/reference/pmod/pmod-interface-specification-1_3_1.pdf) 3. [Pmod LS1 Reference Manual](https://digilent.com/reference/pmod/pmodls1/reference-manual) 4. [Pmod MAXSONAR Reference Manual](https://digilent.com/reference/pmod/pmodmaxsonar/reference-manual) 5. [Pmod DHB1 Reference Manual](https://digilent.com/reference/pmod/pmoddhb1/reference-manual) --- ## Week 2 When determining which scheduling solution your embedded system should use, there are a variety of options that range from a simplistic bare-metal design, like we used in lab 6, to a full embedded Linux distribution (called PetaLinux). Choosing one may come down to factors like: * **Responsiveness and compatibility:** Companies like TI or Xilinx may create their own RTOS (e.g.: TI-RTOS or XilKernel) that work the best on the hardware they tailor it for. Some also follow POSIX standards such that maximum compatibility exists for programming between different devices (e.g.: You can create pthreads on your computer, as well as TI-RTOS and XilKernel as they are POSIX compliant, but not the standard FreeRTOS). * **System resources:** Larger embedded systems may have multi-core systems that support embedded Linux or a combination of systems (PetaLinux + FreeRTOS). * **Licensing:** Certain software packages like Azure RTOS and others commercially available for cloud IoT uses require licensing. For this lab, we will be using FreeRTOS to convert our bare-metal task switcher into a full RTOS-driven system that supports preemption and has a programming feel that is closer to that of programming multi-threaded programs for computers. FreeRTOS has been described as \"the de facto standard\" and \"market leading\" because of its robustness, the wide range of microprocessors supported, and lack of a license needed to use it. Xilinx has deprecated the use of their \"XilKernel\" system and have since removed it in versions of SDK > 2016. FreeRTOS provides a small, robust, and modular kernel. It is highly integrated with the Xilinx SDK and is a free software library option that can be selected when creating a new project. It allows a very high degree of customization, letting users tailor the kernel to an optimal level both in terms of size and functionality with most modifications readily available in the \"FreeRTOS.h\" and \"FreeRTOSConfig.h\" header files. It supports the core features required in a lightweight embedded kernel, however, the version included with the Xilinx 2016.4 SDK is not POSIX compliant and does not support pthreads. FreeRTOS can be used to implement higher level services (such as networking, video, and audio) and subsequently run applications using these services. For this lab, we will be using the same SDK workspace folder provided for labs 5 and 6 to create the FreeRTOS project and migrate our traffic signal from the bare-metal design. If you need to download a fresh copy of the workspace, it can be found here. ### Project Directions * Start off by downloading [this repository](https://github.com/tkamucheka/embedded-systems-lab), which has a few examples for working with your car. * Open your workspace from previous labs and go to File > New > Application Project. If for some reason you do not have a workspace, use the examples workspace in the cloned repo. * When the \"New Project\" preferences window appears, name the project \"lab7\" and in the \"OS Platform\" selection, choose freertos823_xilinx. (Note: if you are using a different version of SDK, your version of FreeRTOS may vary). Click next and choose the empty project option, then click finish. * Copy the files (artyBotLib.h, artyBotLib.c, motorControl.h, motorControl.c, pidController.h, pidController.c) from the ArtyBot_example0/src example directory and paste them into your newly created project's src directory. * With the newly created project, right click on the src folder and create a new file (New > File). Name the file \"main.c\" and paste the following contents in it as a starting point: ```C /* FreeRTOS includes. */ #include \"FreeRTOS.h\" #include \"task.h\" #include \"semphr.h\" /* Xilinx includes. */ #include \"xil_printf.h\" #include \"xparameters.h\" #include \"xgpio.h\" #include \"xintc.h\" /* Other includes */ #include \"artyBotLib.h\" #include \"PmodMAXSONAR.h\" // Car states typedef enum {IDLE, DRIVE, NAVIGATE} State; State state = IDLE; // Shared resource. Mutex driven. SemaphoreHandle_t state_mutex; /* FreeRTOS Tasks */ // ... /* Main Function */ int main(void) { // Setup and init code // Start FreeRTOS Kernel return 0; } ``` * We will attempt to develop our car with a structure similar to the traffic signal from previous labs. Let's attempt to first migrate part of the \"task chooser\" thread that was used in in the previous lab to govern when the other tasks were supposed to run. * To create a thread in FreeRTOS, we first need to create a task handle struct that the kernel will use to associate a task with. Above main(), create a handle called `SupervisorTaskHandle` and initialize it to null, like so: `TaskHandle_t SupervisorTaskHandle = NULL`; * Next, we need to create a task handler function that will execute. Similar to last lab, create a function that will act as a thread runner that takes in a void pointer parameter, like: `void SupervisorTask(void *arg) {...}`. Fill out the contents of this function with just an infinite loop. * Now we are going to formally create the task with xCreateTask. That macro has the following parameters: `xCreateTask(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask)`. These parameters are explained by hovering over the macro name, right-clicking, and opening the declaration (or F3). I've also provided the parameter details below: * **pvTaskCode** Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop). * **pcName** A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN - default is 16. e.g.: \"Supervisor\" * **usStackDepth** The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. * **pvParameters** Pointer that will be used as the parameter for the task being created. * **uxPriority** The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to `( 2 | portPRIVILEGE_BIT )`. * **pvCreatedTask** Used to pass back a handle by which the created task can be referenced * So our xTaskCreate will look like: `xTaskCreate(SupervisorTask, \"Supervisor\", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &SupervisorTaskHandle);` Notice how we are just passing NULL for the parameter and that we are passing the address of the TaskHandle type. If you pass the value directly, your tasks won't be able to suspend/resume if you attempt to use the functions. * Now we must acknowledge an issue before moving forward. We plan on having several tasks being able to write to the state variable when that thread has deemed the condition should move to the next state. E.g.: the IDLE task will set the state to DRIVE, the STOP task will set the state to IDLE and so on. The issue arises when we have multiple threads with the ability to write a variable and a thread trying to read the variable in our preemptive system. We are going to need to implement a mutex around our state variable to ensure that it is written to by one thread at a time. * Go back up to the top of the file where the state variable is globally defined and add the following line below it: `SemaphoreHandle_t state_mutex;` Then back in the main function, we can setup the mutex with the line: `state_mutex = xSemaphoreCreateMutex();` * With this mutex, we can now try and acquire the lock with `xSemaphoreTake(state_mutex, TRY_TICKS)` and we can unlock with `xSemaphoreGive(state_mutex)`. Notice TRY_TICKS in the semaphore take function. It represents the number of RTOS ticks (time unit, by default set to 100 ticks/sec) that the system will try to acquire the lock within, if it can't within the number provided, it will just fail. * Now in our SupervisorTask function infinite loop, we can see if the mutex is locked or unlocked using the return value of a function in an if statement: * Now we can prime which thread needs to run in our Supervisor Task similar to how we did in in the previous lab with the ready flag being set to true/false. `vTaskSuspend(/* TaskHandle_t type */)` will suspend a task from the scheduler and `vTaskResume(/* TaskHandle_t type */)` will add a task back to the pool of tasks to execute. You can add these function calls to the switch statement cases above to set which thread will execute after running the supervisor. * At the end of this block of code when we can make the thread go to sleep for a set amount of time. `vTaskDelay(/* num of ticks */)` will let the task sleep for a certain number of ticks. Notice this is not seconds, as 1 tick = 1/100 second. There is a simple macro to convert ticks to seconds and can be used as a parameter in the vTaskDelay function to sleep for a certain number of milliseconds: `vTaskDelay( pdMS_TO_TICKS(/* ms to sleep */) )`. * > Side note: if you are trying to make an LED flash or stay lit for a certain period of time, the vTaskDelay call in that particular task function should make that task trivial. ```C while(1) { // Acquire mutex lock if( xSemaphoreTake(state_mutex, 10) ) { // We have access to the mutex. // Do critical operations here switch(state) {/* ... */} // Release lock xSemaphoreGive(state_mutex); } // Sleep for a small amount of time // ... } ``` * To start the kernel, add the line `vTaskStartScheduler();` right before the return statement in the main function. * Now that we have gone through the basis of recreating the task choose thread from the previous lab, go ahead a create some tasks that correspond to driving your car. You should have all the function calls you need. * The example project ArtyBot_example0 has some examples of what your states can look like. That being sad, there are many different ways to get this project done. Add extra states if you need them. ### Assignment * Turn your car into a line following robot. The line will be a (white) duct tape track and your car should drive around the track with wheels on either side of the track. There will be an obstacle at the end of the track, use this to stop your car. To do this, you will need: * Use the GPIO PMOD LS1 to detect when your car drives over the line and steer that car back onto the track * Use the PMOD MAXSONAR to detect obstacles and stop the car before the obstacle. * Program the Arty's non-volatile 16 MB Quad-SPI flash memory with your SoC and application so that your application runs when you power on the Arty board. NB: the file names in this section may be different from what you have in your project. Just remember what you named your soc in Vivado and project name in the SDK and the rest should look familiar. If you're unsure ask your TA for help. To program your Arty * Right click your project folder, the project you want to flash onto the board, and select **Generate Linker Script**. On the right side, change all 3 dropdowns from *microblaze_0_local*... to *mig_7series_0_memaddr*. If you are on Linux this might not work. You may need to open the **lscript.ld** file in your project's src directory and manually change all the entries to *mig_7series_0_memaddr*. * Click the **Program Flash** button in the toolbar. Next to Image File, click Browse and navigate to your project folder, then into Debug. Select your_project_name.elf and click open. Next to Offset, enter `0x00C00000`. This is the address offset where your program will be stored in the flash memory. Next to 'Flash Type,' select *S25FL128sxxxxxx0-spi-x1_x2_x4*. **IMPORTANT**, make sure 'Convert ELF to bootloadable SREC format and program' is checked. Click **Program**. * To create a bootloader, in the toolbar select File > New > Application Project. Name the project something like 'bootloader' as shown in the image above. Click **Next**. * Select **SREC SPI Bootloader**, and select **Finish**. * We need to make a few changes to our bootloader before loading it onto the Arty board. First, we need to set the 'address offset' so the bootloader can find our application. In the 'Bootloader' project, open the blconfig.h file and change the **FLASH_IMAGE_BASEADDR** to `0x00C00000`. Note, this same address you used when you flashed your application onto the flash memory earlier. * > **Optional**, if you wish to improve your ArtyBot's startup time. Edit the file bootloader.c and comment out the line `#define VERBOSE`. This will turn off console logging. **NB:** Console logs may be useful when you're initially setting things up. * Click the **Program FPGA** button in the toolbar. In the right half of the Software Configuration section, there is a cell that says `bootloop`. Click the right side of this cell to reveal a drop-down menu. Select **Bootloop.elf** from the list, then click Program. This will generate a bit file with the MicroBlaze's memory initialized with the program that you have written. The Arty is also programmed and if everything went well you should see your application running in your favorite console application (e.g. Putty or TeraTerm) * Almost there, click the **Program Flash** button in the toolbar. Next to Image File, click Browse and navigate to the SDK workspace, then into `base_soc_wrapper_hw_platform_0`. Select download.bit and click **Open**. Next of Offset, enter `0x0`. Next to Flash Type, select `S25FL128sxxxxxx0-spi-x1_x2_x4`. Click **Program**. * Congratulations, you have flashed the bootloader and your application to the non-volatile SPI Qflash memory. Next time you power on the board, the bootloader will be copied from the flash memory and when it runs, it will execute your application. ### Pre-Lab Questions None this week. Lucky you! ### References 1. FreeRTOS Manual [https://www.freertos.org/FreeRTOS-quick-start-guide.html](https://www.freertos.org/FreeRTOS-quick-start-guide.html) (expand API Reference on the side for full documentation on function calls) ",
    "url": "/classes/embedded-systems/labs/lab6/",
    
    "relUrl": "/classes/embedded-systems/labs/lab6/"
  },"12": {
    "doc": "Lab 3",
    "title": "Lab 3",
    "content": "# Lab 3: Fayetteville Bike Crossing In this lab you will use your Arty-7 board and knowledge of push buttons and LEDs from the previous lab to create a controller for Fayetteville’s bike/waking paths. The bike/walking path crosses streets where cyclists/walkers have a control box they can use to control the traffic lights for cars Cyclist/Walker control Boxes: One on each side of the path that crosses the road. Cyclists/Walkers push the button in the box to request a crossing and control the traffic lights. **Traffic Lights:** 1. Solid Green: Cars are free to travel through the crossing at speed. This signifies no cyclists/walkers have requested a crossing. 2. Solid Red: Cars must stop. This signifies a cyclist/walker is in the crosswalk. 3. Blinking Red: Cars must slow and look for cyclists/walkers. A blinking red occurs prior to and immediately following a solid red light. Operation and control of the push button control box: When a cyclist/walker pushes the button in the control box: 1. If the traffic lights are green they immediately start flashing red for 6 seconds 2. If the traffic lights are already flashing red the new button push will flash for an additional 6 seconds from the time of the new button push. 3. If the traffic lights are solid red, the button push will have no effect and the solid red will display for 4 seconds from the first button push. So the states in order go: green → blinking red → solid red → blinking red → green. In general, any of the push buttons should activate the crosswalk logic, but all 4 RGB LEDs should be used for the status for the cars. ## Lab Directions This is a two part lab that will run in two weeks. In the first week you will have to simulate the 4 and 6-second delays using dummy loops. In the second week you will replace the dummy loops with a timer. * **Week 1.** In the first week you will write the code to control two push buttons signifying the two cyclist/walkers control boxes and two LEDs signifying the traffic lights. After a control box is pushed, the traffic lights automatically transition between blinking red, solid red, blinking red, and then back to green. You will need to simulate this transition using delay loops. Ie., after a button is pushed the blinking red should appear for approximately 6 seconds, then switch to solid red for 4 seconds, back to blinking red for 6 seconds, and then back to green. Since you don’t have timers you will have to write nested loops that essentially do nothing useful but delay for the appropriate amount of time (approximately, can be a little fast or slow) before switching to the next color. You will also have to blink the red LED on and off at approximately 1 second intervals to simulate the flashing red. **Step 1:** In SDK, create a new blank Application project using the base-soc.sdk workspace like in last lab. Create a lab3.c file and populate it with the necessary empty main() function and includes. 1. To start off, we can see this lab is going to utilize waiting in varying time intervals based around the second unit. It would probably be helpful if we created a function to wait for us. Let's make a `delay_ms(int ms)` function, so we can reuse it in other portions of this lab and possible future labs: * Copy/paste the following to your source code file: ```c void delay_ms(int ms) { for(int i = 0; i < 134 * ms; i++) { asm(\"nop\"); } } ``` *You may need to tweak the loop so that it approximates a second when delay_ms(1000) is called.* Now that you have a working delay function, you can delay for one second by calling `delay_ms(1000);` in your main function. Create a `while(1)` section in your main function and create the desired functionality described above using what you have learned from last lab. It would be helpful to break the individual sub-routines down into functions for organization and modularity. **Step 2:** You will factor your code into a Finite State Machine model for creating state transitions. You should be familiar with FSM models from Digital Design and System Synthesis. At a high level, an FSM is an abstract machine or mathematical model that describes the transitions from a current state and set of inputs to a next state with a set of outputs. FSMs are very convenient for modeling and implementing the behaviors of embedded and real time systems as a series of transitions that result from the presence of external inputs (sensors, buttons) that result in the setting of external outputs (actuators, relays etc). You should have some experience from Digital Design and System Synthesis in writing Moore and Mealy FSMs in Verilog or VHDL. We can model an FSM in C using the switch(), case 1, case 2... constructs. Below is a skeleton template (not complete) of an FSM for the Fayetteville bike crossing. ```c typedef enum {RED, GREEN, FLASH_RED_START, FLASH_RED_END} State; // Create state variables State state, next_state; // Basic template for FSM model void FSM_tick() { switch(state) { case RED: // code for RED state & logic for next_state next_state = ?; // next state after RED break; case GREEN: // code for GREEN state & logic for next_state next_state = ?; // next state after GREEN break; case FLASH_RED_START: // code for FLASH_RED_START state & logic for next_state next_state = ?; // next state after RED_START break; case FLASH_RED_END: // code for FLASH_RED_END state & logic for next_state next_state = ?; // next state after FLASH_RED_END break; } state = next_state; // update next state } int main() { // initialize crossing to a state from the enum state = ?; // keep on loopin' while(1) { // cycle through traffic light pattern FSM_tick(); } return 0; } ``` ## Submission Nothing will be due for the first week, though you should double-check your design and ensure it produces the desired output. Make sure your design is modular as well as we will refactor this code and use timers in place of the dummy delay loops in the second week. For the submission after week 2, you will turn in your report which should contain a state transition graph of your FSM, and your C file in a zip archive. ",
    "url": "/classes/embedded-systems/labs/lab3/",
    
    "relUrl": "/classes/embedded-systems/labs/lab3/"
  },"13": {
    "doc": "Lab 1",
    "title": "Lab 1:",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab1/#lab-1",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#lab-1"
  },"14": {
    "doc": "Lab 1",
    "title": "Prelab Questions",
    "content": ". | What is an FPGA? | What is a system-on-chip? Why is it different from your desktop computer system? | What does soft-core IP mean? | What does it mean to cross-compile a program? | Why does it take so long to configure/build the Hardware portion of your system on the FPGA? | How does the desktop computer program the FPGA, how does it monitor the FPGA? | . ",
    "url": "/classes/embedded-systems/labs/lab1/#prelab-questions",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#prelab-questions"
  },"15": {
    "doc": "Lab 1",
    "title": "Description",
    "content": "In laboratory 1 you will complete a provided boilerplate design of a System-on-Chip (SoC) using the Xilinx-Vivado development suite and targeted at the Arty-A7-35 development board. Your design will contain a MicroBlaze soft-processor, a serial port, and three GPIO devices that interface with components on the Arty board. The processor will be connected to the serial port and GPIO peripherals in a shared-bus architecture. You will then program this SoC using the C programming language, to print out your name and student ID five times to the screen of a desktop computer which is connected to the Arty-7 development board using the serial port. There will be 3 screenshot requirements for your report, so ensure you read the following instructions carefully. Project Assignment . Use the provided base project to create a basic system-on-chip. Synthesize your system-on-chip, compile your software project, and combine them into a bitstream. Download your bitstream onto the Arty-A7-35 development board. Open this document with ReadSpeaker docReader and execute it. Create a software project and make it print out your name five times. This may not seem like much, but at the end of this laboratory you will have created a system-on-chip and executed a program on top of it in a bare metal environment. This represents a very basic but fully functional embedded system. ",
    "url": "/classes/embedded-systems/labs/lab1/#description",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/#description"
  },"16": {
    "doc": "Lab 1",
    "title": "Lab 1",
    "content": " ",
    "url": "/classes/embedded-systems/labs/lab1/",
    
    "relUrl": "/classes/embedded-systems/labs/lab1/"
  },"17": {
    "doc": "Labs",
    "title": "Labs",
    "content": "# Lab Repository ## At A Glance | Date | Lab | ----------- | --------------------------------------------------- | 8/21 - 8/25 | Prelab: download [Vivado 2019.1](https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/archive.html) on home computer | 8/29 - 9/2 | [Lab 1: How to build a basic SoC](./lab1) | 9/5 - 9/9 | [Lab 2: GPIOs + Basic MicroBlaze System](./lab2) | 9/12 - 9/23 | [Lab 3: Fayetteville Bike Crossing](./lab3) | 9/26 - 10/7 | [Lab 4: Timers](./lab4) | 9/26 - 10/7 | [Lab 5: Interrupt Driven Microblaze System](./lab5) | 9/26 - 10/7 | [Lab 6: Autonomous Vehicle](./lab6) | ## Lab Schedule {% assign modules = site.modules | where: 'course', '4114-labs' %} {% for module in modules %} {{ module }} {% endfor %} ",
    "url": "/classes/embedded-systems/labs/",
    
    "relUrl": "/classes/embedded-systems/labs/"
  },"18": {
    "doc": "CSCE 4114 Embedded Systems",
    "title": "CSCE 4114 Embedded Systems",
    "content": "# CSCE 4114/5114 Embedded Systems ## Course Description The design and analysis of modern HW/SW co-designed embedded systems. Modern design flows and approaches for creating and controlling System on Chip integrated components. Real time and reactive modeling and implementation of control loops and data processing. System level integration techniques for multiprocessor components and accelerators. This class will make use of the Xilinx/Digilent Arty7 Development Board. This development board contains a modern Artix 7-series FPGA along with various peripherals such as Ethernet, USB, Audio In/Out, LEDs, buttons, switches, VGA, etc. Various System-On-Chip (SoC) architectures will be developed during this class, all of which will be implemented within the fabric of the FPGA. Most, if not all, of the SoCs developed during this class will use the MicroBlaze processor; a soft 32-bit processor core developed by Xilinx. The instruction set architecture, or ISA, of the MicroBlaze will be studied and used throughout this class, in order to teach students the relationships between high-level languages, assembly language, and the actual hardware implementation of computer systems. ## [Syllabus](/classes/embedded-systems/syllabus/) ## Textbook [CSCE 4114: Embedded Systems](https://learn.zybooks.com/zybook/UARKCSCE4114AndrewsFall2023), Frank Vahid, Tony Givargis, Bailey Miller, Zybooks ## Schedule All lectures can be found through the following link: [CSCE 4114 Lecture Page](/classes/embedded-systems/schedule/). ## Lab Repository All lab projects can be found through the following link: [CSCE 4114 Lab Page](./labs). ",
    "url": "/classes/embedded-systems/",
    
    "relUrl": "/classes/embedded-systems/"
  },"19": {
    "doc": "Classes",
    "title": "Classes",
    "content": "# Classes {:.no_toc} ## Table Of Contents {:.no_toc .text-delta} 1. TOC {:toc} --- ## Graduate Classes Offered by the CSDL Lab ### CSCE 5843 Reconfigurable Computing A graduate-level course on the state of the art in Reconfigurable Computing ### Multiprocessor Systems-On-Chip A graduate-level course that covers modern MPSoC design issues and methodologies. ### CSCE 5013 Real-Time Operating Systems (RTOS) A senior level/graduate-level course that covers real-time systems and the issues related to operating system design for those systems. ### CSCE 5013 Adaptive Systems A senior level/graduate-level course that gives student the basics of autonomic systems and have them design a workable adaptive system, conceptually and technically, based on the partial reconfiguration capabilities of FPGAs. ## Undergraduate Classes Offered by the CSDL Lab ### CSCE 2214 Computer Organization An introductory course in computer organization and architecture including topics in digital logic, digital systems, and memory structure. ### CSCE3613 Operating Systems An introduction to operating systems including topics in concepts and system structures, process management, memory management, files and storage management, distributed systems, and case studies. ### EECS 388 Kansas University Computer Systems & Assembly Language (MicroBlaze-based) An undergraduate-level course to computer systems and assembly language that utilizes Xilinx FPGAs and MicroBlaze soft processors. ### [CSCE 4114 Embedded Systems](/classes/embedded-systems) A senior level/graduate-level course that covers modern Computer Architecture. ### [CSCE 4213 Computer Architecture](/classes/computer-architecture) A senior level/graduate-level course that covers modern Computer Architecture. ### CSCE 2114 Digital Design An undergraduate course that covers basic concepts of binary and digital systems,along with VHDL programming ",
    "url": "/classes/",
    
    "relUrl": "/classes/"
  },"20": {
    "doc": "Home",
    "title": "Home",
    "content": "![University of Arkansas](/assets/images/UA_Logo.png){: width=\"130\"} ![CSCE](/assets/images/Csce.png) # Computer Systems Design Laboratory ## Laboratory Overview --- Welcome to the Computer Systems Design Laboratory at the University of Arkansas. Research in CSDL encompasses system specification and verification, modeling abstractions, HW/SW co-design, CAD/CAE, operating systems, special purpose architectures, compilers, security, special computer architectures, and real-time embedded systems. Current research being done in the Computer Systems Design Laboratory (CSDL) can be viewed on our Projects page. Knowledge is also folded back into both the undergraduate and graduate curriculum in some of our Classes, Lab Notes, and through Reading Groups. The faculty of the CSDL hold primary teaching responsibility for departmental undergraduate classes in digital design, computer organization, computer architecture, embedded systems, and systems modeling. Graduate classes taught by CSDL faculty span reconfigurable computing, multiprocessor systems on chip (MPSoC), and asynchronous logic design. The CSDL hosts visiting researchers and scholars from other research groups world wide, and supports a colloquium series of invited experts. Undergraduate, Masters, and PhD students form the core of CSDL in an interdisciplinary and team based environment. We encourage you to explore the research and teaching components of our laboratory. ## Areas of Research --- 1. Real-Time and Embedded Systems Software 2. Reconfigurable Computing 3. Multiprocessor Systems on Chip (MPSoC) 4. Heterogeneous Computing 5. System Design 6. Computer Architecture 7. HW/SW Co-Design 8. Hardware Acceleration Technologies (FPGAs, GPUs, etc.) ",
    "url": "/",
    
    "relUrl": "/"
  },"21": {
    "doc": "People",
    "title": "People",
    "content": "# Laboratory Personnel ## Professors {% assign Professors = site.staffers | where: 'role', 'Professor' %} {% for staffer in Professors %} {{ staffer }} {% endfor %} ## Students {% assign teaching_assistants = site.staffers | where: 'role', 'Graduate Assistant' %} {% assign num_teaching_assistants = teaching_assistants | size %} {% if num_teaching_assistants != 0 %} {% for staffer in teaching_assistants %} {{ staffer }} {% endfor %} {% endif %} ",
    "url": "/people/",
    
    "relUrl": "/people/"
  },"22": {
    "doc": "Publications",
    "title": "Publications",
    "content": "# Publications {:.no_toc} ## Publications {: .no_toc .text-delta } 1. TOC {:toc} --- ## 2023 - MD Arafat Kabir, Ehsan Kabir, Joshua Hollis, Eli Levy-Mackay, Atiyehsadat Panahi, Jason Bakos, Miaoqing Huang, and David Andrews, \"FPGA Processor In Memory Architectures (PIMs): Overlay or Overhaul?\" The 33rd International Conference on Field-Programmable Logic and Applications (FPL 2023), pp. 1-7, September 2023. - Ehsan Kabir, Daniel Coble, Joud N. Satme, Austin R.J. Downey, Jason D. Bakos, David Andrews, and Miaoqing Huang, \"Accelerating LSTM-based High-Rate Dynamic System Models,\" The 33rd International Conference on Field-Programmable Logic and Applications (FPL 2023), pp. 1-6, September 2023. - MD Arafat Kabir, Joshua Hollis, Atiyehsadat Panahi, Jason Bakos, Miaoqing Huang, and David Andrews, \"Making BRAMs Compute: Creating Scalable Computational Memory Fabric Overlays ,\" The 31st IEEE International Symposium On Field-Programmable Custom Computing Machines (FCCM 2023), pp. 1-1, May 2023.[IEEE](https://doi.org/10.1109/FCCM57271.2023.00052) ## 2022 - T. Kamucheka, A. Nelson, D. Andrews and M. Huang, \"A Masked Pure-Hardware Implementation of Kyber Cryptographic Algorithm,\" 2022 International Conference on Field-Programmable Technology (ICFPT), Hong Kong, 2022, pp. 1-1, [IEEE](https://doi.org/10.1109/ICFPT56656.2022.9974404) - A. Panahi, E. Kabir, A. Downey, D. Andrews, M. Huang and J. D. Bakos, \"High-Rate Machine Learning for Forecasting Time-Series Signals,\" 2022 IEEE 30th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), New York City, NY, USA, 2022, pp. 1-9, [IEEE](https://ieeexplore.ieee.org/abstract/document/9786127) - Kabir, E., Poudel, A., Aklah, Z., Huang, M., Andrews, D. (2022). A Runtime Programmable Accelerator for Convolutional and Multilayer Perceptron Neural Networks on FPGA. In: Gan, L., Wang, Y., Xue, W., Chau, T. (eds) Applied Reconfigurable Computing. Architectures, Tools, and Applications. ARC 2022. Lecture Notes in Computer Science, vol 13569. Springer, Cham. [Springer](https://doi.org/10.1007/978-3-031-19983-7_3) - H. Liu, A. Panahi, D. Andrews and A. Nelson, \"An FPGA-Based Upper-Limb Rehabilitation Device for Gesture Recognition and Motion Evaluation Using Multi-Task Recurrent Neural Networks,\" in IEEE Sensors Journal, vol. 22, no. 4, pp. 3605-3615, 15 Feb.15, 2022, [IEEE](https://doi.org/10.1109/JSEN.2022.3141659). ## 2021 - A. Panahi, S. Balsalama, A. -T. Ishimwe, J. M. Mbongue and D. Andrews, \"A Customizable Domain-Specific Memory-Centric FPGA Overlay for Machine Learning Applications,\" 2021 31st International Conference on Field-Programmable Logic and Applications (FPL), Dresden, Germany, 2021, pp. 24-27, [IEEE](https:doi.org/10.1109/FPL53798.2021.00012). - Tendayi Kamucheka, Michael Fahr, Tristen Teague, Alexander Nelson, David Andrews, and Miaoqing Huang, \"Power-based Side Channel Attack Analysis on PQC Algorithms\", Cryptology ePrint Archive, 2021 [url](https://eprint.iacr.org/2021/1021) ## 2020 - S. Basalama, A. Panahi, A. -T. Ishimwe and D. Andrews, \"SPAR-2: A SIMD Processor Array for Machine Learning in IoT Devices,\" 2020 3rd International Conference on Data Intelligence and Security (ICDIS), South Padre Island, TX, USA, 2020, pp. 141-147, [IEEE](https://ieeexplore.ieee.org/document/9323000) - H. Liu, A. Panahi, D. Andrews and A. Nelson, \"FPGA-Based Gesture Recognition with Capacitive Sensor Array using Recurrent Neural Networks,\" 2020 IEEE 28th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), Fayetteville, AR, USA, 2020, pp. 225-225, [IEEE](https://doi.org/10.1109/FCCM48280.2020.00056) ## 2019 - A. Panahi, K. Stokke and D. Andrews, \"A Library of FSM-based Floating-Point Arithmetic Functions on FPGAs,\" 2019 International Conference on ReConFigurable Computing and FPGAs (ReConFig), Cancun, Mexico, 2019, pp. 1-8, [IEEE](https://doi.org/10.1109/ReConFig48160.2019.8994776) - Hansmeier, T., Platzner, M., Pantho, M.J.H. et al. An Accelerator for Resolution Proof Checking based on FPGA and Hybrid Memory Cube Technology. J Sign Process Syst 91, 1259–1272 (2019). [Journal of Signal Processing Systems](https://doi.org/10.1007/s11265-018-1435-y) ## 2018 - M. J. H. Pantho, J. Mandebi Mbongue, C. Bobda and D. Andrews, \"Transparent Acceleration of Image Processing Kernels on FPGA-Attached Hybrid Memory Cube Computers,\" 2018 International Conference on Field-Programmable Technology (FPT), Naha, Japan, 2018, pp. 342-345, [IEEE](https://doi.org/10.1109/FPT.2018.00069) - J. Mbongue, F. Hategekimana, D. Tchuinkou Kwadjo, D. Andrews and C. Bobda, \"FPGAVirt: A Novel Virtualization Framework for FPGAs in the Cloud,\" 2018 IEEE 11th International Conference on Cloud Computing (CLOUD), San Francisco, CA, USA, 2018, pp. 862-865, [IEEE](https://doi.org/10.1109/CLOUD.2018.00122) - M. J. H. Pantho, J. M. Mbongue, C. Bobda, D. Andrews and M. Asadinia, \"Enabling Transparent Acceleration of OpenCV Library Kernels on a Hybrid Memory Cube Computer,\" 2018 IEEE 26th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), Boulder, CO, USA, 2018, pp. 217-217, [IEEE](https://doi.org/10.1109/FCCM.2018.00051) - Hansmeier, T., Platzner, M., Andrews, D. (2018). An FPGA/HMC-Based Accelerator for Resolution Proof Checking. In: Voros, N., Huebner, M., Keramidas, G., Goehringer, D., Antonopoulos, C., Diniz, P. (eds) Applied Reconfigurable Computing. Architectures, Tools, and Applications. ARC 2018. Lecture Notes in Computer Science(), vol 10824. [Springer](https://doi.org/10.1007/978-3-319-78890-6_13) - Sen Ma, Xuan Shi & David Andrews (2018) Parallelizing maximum likelihood classification (MLC) for supervised image classification by pipelined thread approach through high-level synthesis (HLS) on FPGA cluster, Big Earth Data, 2:2, 144-158, https://doi.org/10.1080/20964471.2018.1470249 ## 2016 - S. Ma, D. Andrews, S. Gao and J. Cummins, \"Breeze computing: A just in time (JIT) approach for virtualizing FPGAs in the cloud,\" 2016 International Conference on ReConFigurable Computing and FPGAs (ReConFig), Cancun, Mexico, 2016, pp. 1-6,[IEEE](https://doi.org10.1109/ReConFig.2016.7857159) - H. Ding, S. Ma, M. Huang and D. Andrews, \"OOGen: An Automated Generation Tool for Custom MPSoC Architectures Based on Object-Oriented Programming Methods,\" 2016 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW), Chicago, IL, USA, 2016, pp. 233-240, [IEEE](https://doi.org/10.1109/IPDPSW.2016.23) - Eugene Cartwright, \"Enabling Runtime Profiling to Hide and Exploit Heterogeneity within Chip Heterogeneous Multiprocessor Systems (CHMPS)\", Ph.D. Dissertation at the University of Arkansas (May, 2016). Dissertation - Invited Talk \"JIT Run Time Assembly of Hardware Accelerators\", Paderborn University, Paderborn Germany, June 30, 2016 - Invited Paper David Andrews, Marco Platzner, \"Programming Models for Reconfigurable Manycore Systems\" Proceedings of the 11th International Symposium on Reconfigurable Communication-centric Systems-on-Chip (ReCoSoC 2016) Tallinn, Estonia June 27-29, 2016 pp. 1-8 [IEEE](https://doi.org/10.1109/ReCoSoC.2016.7533897) - S. Ma, Z. Aklah and D. Andrews, \"Run time interpretation for creating custom accelerators,\" 2016 Design, Automation & Test in Europe Conference & Exhibition (DATE), Dresden, Germany, 2016, pp. 900-905 [IEEE](https://ieeexplore.ieee.org/abstract/document/7459436) - Sen Ma, Zeyad Aklah, David Andrews, \"Just In Time Assembly of Accelerators\", Proceedings of the 24th ACM/SIGDA International Symposium on Field-Programmable Gate Arrays (FPGA 2016), Monterey California, February 21-23, 2016 pp. 173-178, https://arxiv.org/abs/1603.01187 - Zeyad Aklah, Sen Ma and David Andrews, \"A Dynamic Overlay Supporting Just-In-Time Assembly to Construct Customized Hardware Accelerators\" 2nd International Workshop on Overlay Architectures for FPGAs (OLAF). Sunday workshop at the 24th ACM/SIGDA International Symposium on Field-Programmable Gate Arrays (FPGA 2016) 2 page abstract. ## 2015 - Sen Ma, Hongyuan Ding, Miaoqing Huang and David Andrews, \"Archborn: An Open Source Tool for Automated Generation of Chip Heterogeneous Multiprocessor Architectures\", Proceedings of the International Conference on ReConFigurable Computing and FPGAs, Cancun Mexico, Dec 7-9, 2015 - Nithin George, Hyoukloong Lee, David Novo, Muhsen Owaida, Davi Andrews, Kunle Olukotun, and Paolo Ienne,\"Automatic Support for Multi-Module Parallelism from Computational Patterns\", Proceedings of the 25th International Conference on Field Programmable Logic and Applications (FPL) pp.93-100, London, England, 2015 - Sen Ma, Zeyad Aklah and David Andrews, \"A Run Time Interpretation Approach for Creating Custom Accelerators\", Proceedings of the 25th International Conference on Field Programmable Logic and Applications (FPL), pp.472-475, London, England, 2015 - Paolo Ienne, David Andrews, Walid Najjar, Reconfigurable Computing for the Masses, Really ? Workshop at the 25th International Conference on Field Programmable Logic and Applications (FPL) London, England, 2015 - David Andrews, Can We Finally Allow Software Programmers to Create Hardware Accelerators ? Invited Talk at ETH Zurich, April 30, 2015 - Keynote Talk David Andrews, Will the future success of Reconfigurable Computing require a paradigm shift in our research communities thinking?, 11th International Symposium on Applied Reconfigurable Computing (ARC), Bochum Germany, April 16, 2015 - Zeyad Aklah and David Andrews, \"A Flexible Multilayer Perceptron Co-Processor for FPGAs\" Proceedings of the 11th International Symposium on Applied Reconfigurable Computing (ARC), pp. 427-434, Bochum Germany, April 13-17, 2015 ## 2014 - Cartwright, Eugene; Sadeghian, Alborz; Ma, Sen; Andrews, David, \"Achieving Portability and Efficiency over Chip Heterogeneous Multiprocessor Systems,\" Field Programmable Logic and Applications (FPL), 2014 24th International Conference on, pp.1-4, 2-4 Sept. 2014 - Sen Ma, David L. Andrews: On energy efficiency and Amdahl's law in FPGA based chip heterogeneous multiprocessor systems (abstract only). FPGA 2014: 253 - David Andrews, \"Operating Systems Research for Reconfigurable Computing\", IEEE Micro, vol.34, no. 1, pp. 54-58, Jan.-Feb. 2014, doi:10.1109/MM.2014.1 ## 2013 - Gerard Allwein, William Harrison and David Andrews,Simulation Logic Journal of Logic and Logical Philosophy, DOI: 10.12775/LLP.2013.0127, September 2013 - Miaoqing Huang and David Andrews, Modular Design of Fully Pipelined Reduction Circuits on FPGAs, IEEE Transactions on Parallel and Distributed Systems, Vol. 24, No 9., Sept. 2013, pp.1818-1826 ## 2012 - Sen Ma, Miaoqing Huang, David Andrews, Developing Application-Specific Multiprocessor Platforms on FPGAs, Poster session of Reconfig 2012 - E. Cartwright, A. Fahkari, Sen Ma, C. Smith, M. Huang, D. Andrews, Jason Agron, Automating the Design of MLUT MPSOPC FPGA's in the Cloud, Proceedings of the 22nd International Conference on Field Programmable Logic and Applications (FPL), Oslo, Norway, August 29-31, 2012 - Miaoqing Huang and Liang Men, Improving the Performance of On-Board Cache for Flash-based Solid-State Drives, in Proceedings of The 7th IEEE International Conference on Networking, Architecture, and Storage (NAS 2012), Xiamen, China, June 28-30, 2012. - D. Andrews, Visions for RC in the Next Twenty Years, Presentation at Sunday Workshop on Reconfigurable Computing and FCCM: What have we done in 20 years, and what will Reconfigurable Computing mean in 2032?, FCCM2012, April 2012. - Sen Ma, Miaoqing Huang, Eugene Cartwright, and David Andrews, Scalable Memory Hierarchies for Embedded Manycore Systems, in Proceedings of The 8th International Symposium on Applied Reconfigurable Computing (ARC 2012), LNCS 7199, pp. 151-162, Hong Kong, China, March 19-23, 2012. ## 2011 - J. Agron, D. Andrews, M. Happe, E. Lubbers, and M. Platzner, Multithreaded Programming of Reconfigurable Embedded Systems, in Reconfigurable Embedded Control Systems: Applications for Flexibility and Agility, M. Khalgui and H.-M. Hanisch, Eds. Information Science Publishing, 2011, ch. 2, pp. 31--54. - Miaoqing Huang, Kris Gaj, and Tarek El-Ghazawi, New Hardware Architectures for Montgomery Modular Multiplication Algorithm, IEEE Transactions on Computers, vol. 60, no. 7, pp. 923-936, July 2011. - Ozlem Kilic, Miaoqing Huang, Charles Conner, and Mark S. Mirotznik, Hardware Accelerated Design of Millimeter Wave Antireflective Surfaces: A Comparison of Field-Programmable Gate Array (FPGA) and Graphics Processing Unit (GPU) Implementations, ACES (The Applied Computation Electromagnetics Society) Journal, vol. 26, no. 3, pp. 188-198, March 2011. - Liang Zhou, Miaoqing Huang, and Scott C. Smith, High-Performance and Area-Efficient Hardware Design for Radix-2^k Montgomery Multipliers, in Proceedings of The 2011 International Conference on Computer Design (CDES'11), Las Vegas, USA, July 18-21, 2011. - David Andrews, Design Flows and Run Time Systems for Heterogeneous Multiprocessor Systems on Programmable Chips (MPSoPCs), Printed abstract in Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms, Las Vegas, USA, July 18-21, 2011 pp.253-254 - Lingyuan Wang, Miaoqing Huang, and Tarek El-Ghazawi, Exploiting Concurrent Kernel Execution on Graphic Processing Units, in Proceedings of The 2011 International Conference on High Performance Computing & Simulation (HPCS 2011), pp. 24-32, Istanbul, Turkey, July 4-8, 2011. (Acceptance ratio: 48/171=28.07%) - Eugene Cartwright, Sen Ma, David Andrews, and Miaoqing Huang, Creating HW/SW Co-Designed MPSoPC's from High Level Programming Models, in Proceedings of Workshop on Multiprocessor Systems on (Programmable) Chips (MPSoC 2011) as part of The 2011 International Conference on High Performance Computing & Simulation (HPCS 2011), pp. 554-560, Istanbul, Turkey, July 4-8, 2011. - Lingyuan Wang, Miaoqing Huang, Vikram K. Narayana, and Tarek El-Ghazawi, Scaling Scientific Applications on Clusters of Hybrid Multicore/GPU Nodes, in Proceedings of The 8th ACM International Conference on Computing Frontiers (CF'11), Ischia, Italy, May 3-5, 2011. (Acceptance ratio: 22/101=21.8%) - Jorge Ortiz and David Andrews, A Streaming High-Throughput Linear Sorter System with Contention Buffering, International Journal of Reconfigurable Computing, vol. 2011, Article ID 963539, 12 pages, 2011. doi:10.1155/2011/963539 ## 2010 - Miaoqing Huang, David Andrews, and Jason Agron, \"Operating System Structures for Multiprocessor Systems on Programmable Chip,\" in Proceedings of 2010 International Conference on ReConFigurable Computing and FPGAs (ReConFig 2010), Cancun, Mexico, Dec. 13-15, 2010. - David Andrews, Building Heterogeneous Systems With a Hardware Microkernel Presentation given at Xilinx, San Jose, California, August 16, 2010 - Miaoqing Huang and David Andrews, Modular Design of Fully Pipelined Accumulators, in Proceedings of The 2010 International Conference on Field-Programmable Technology (FPT'10), Beijing, China, Dec. 8-10, 2010. - Jason Agron, Hardware Microkernels - A Novel Method for Constructing Operating Systems for Heterogeneous Multi-Core Platforms, Ph.D. Dissertation at the University of Arkansas (August, 2010). Dissertation and Presentation Slides. - David Andrews, Christian Plessl, Configurable Processor Architectures: History and Trends, Abstract of Invited Talk in Proceedings of the 10th International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA), Las Vegas, Nevada USA, July 12-15, 2010 - Miaoqing Huang, Lingyuan Wang, and Tarek El-Ghazawi, \"Accelerating Double Precision Floating-point Hessenberg Reduction on FPGA and Multicore Architectures,\" in Proceedings of 2010 Symposium on Application Accelerators in High Performance Computing (SAAHPC'10), Knoxville, Tennessee, USA, July 13-15, 2010. - David Andrews, Reconfigurable Architectures in the Heterogeneous Manycore Era, Proceedings of the 8th International Conference on High Performance Computing and Simulation (HPCS2010), Keynote Speech in the Special Session on Embedded and Reconfigurable Computing (ERC2010) Caen France, June 28-July 2, 2010 - Miaoqing Huang, Olivier Serres, Vikram K. Narayana, Tarek El-Ghazawi, and Gregory Newby, \"Efficient Cache Design for Solid-State Drives,\" in Proceedings of The ACM International Conference on Computing Frontiers 2010 (CF'10), pp. 41-50, Bertinoro, Italy, May 17-19, 2010. (Acceptance ratio: 30/113=26.5%) - Jason Agron and David Andrews, Distributed Hardware-Based Microkernels: Making Heterogeneous OS Functionality A System Primitive, Proceedings of The 18th Annual IEEE Symposium on Field-Programmable Custom Computing Machines, Charlotte, North Carolina. May 2-4, 2010. - Miaoqing Huang and Ozlem Kilic, \"Reaping the processing potential of FPGA on double-precision floating-point operations: an eigenvalue solver case study,\" in Proceedings of the 18th Annual International IEEE Symposium on Field-Programmable Custom Computing Machines (FCCM 2010), pp. 95-102, Charlotte, North Carolina, USA, May 2-4, 2010. (Acceptance ratio: 24/132=18.2%) - Ozlem Kilic, Miaoqing Huang, Charles Conner, and Mark S. Mirotznik, \"Hardware Accelerated Design of Millimeter Wave Antireflective Surfaces,\" in Proceedings of the 26th ACES Conference (ACES 2010), Tampere, Finland, April 25-29, 2010. - Jorge Ortiz and David Andrews, A Configurable High-Throughput Linear Sorter System , Proceedings of the 17th Reconfigurable Architectures Workshop (RAW) at International Symposium on Parallel and Distributed Systems (IPDPS), Atlanta, Georgia April 19-23, 2010 Presentation (PDF) - Ozlem Kilic and Miaoqing Huang, \"Overview of Reconfigurable Computing Platforms and Their Applications in Electromagnetics Applications\", ACES (The Applied Computation Electromagnetics Society) Journal, vol.25, no.4, pp.283-293, April, 2010. - Miaoqing Huang, Olivier Serres, and Tarek El-Ghazawi, and Gregory Newby, \"Parameterized Hardware Design on Reconfigurable Computers: An Image Processing Case Study,\" International Journal of Reconfigurable Computing, vol.2010, pp.1-11, April, 2010, doi:10.1155/2010/454506. - Jason Agron and David Andrews, Efficient OS Services for Heterogeneous and Reconfigurable Manycores, Proceedings of the Many-Core and Reconfigurable Supercomputing Conference (MRSC'2010), Rome, Italy. ## 2009 - Jason Agron and David Andrews, Building Heterogeneous Reconfigurable Systems With a Hardware Microkernel. Proceedings of the 7th International Conference on Hardware/Software Codesign and System Synthesis, CODES+ISSS, Grenoble, France, October 2009. Presentation (PDF) - Jason Agron and David Andrews, Hardware Microkernels for Heterogeneous Manycore Systems. Proceedings of the First International Workshop on Real-time Systems on Multicore Platforms: Theory and Practice (XRTS) held in conjunction with the 38th International Conference on Parallel Processing (ICPP), Vienna, Austria, September 2009. - Jason Agron and David Andrews, Building Heterogeneous Reconfigurable Systems Using Threads. Proceedings of the 19th International Conference on Field Programmable Logic and Applications (FPL), Prague, Czech Republic, September 2009. - Teng Li, Miaoqing Huang, Tarek El-Ghazawi, and H. Howie Huang, \"Reconfigurable Active Disk: An FPGA Accelerated Storage Architecture for Data-Intensive Applications,\" in Proceedings of 2009 Symposium on Application Accelerators in High-Performance Computing (SAAHPC'09), Urbana, Illinois, USA, July 28-30, 2009. - Jason Agron, Domain-Speciﬁc Language for HW/SW Co-Design for FPGAs (PRE-PRINT). Proceedings of the IFIP Working Conference on Domain Specific Languages (DSL WC), Volume 5658 of Lecture Notes in Computer Science, pages 262-284. Springer-Verlag, July, 2009. - William Harrison, Adam Procter, Jason Agron, Garrin Kimmell, and Gerard Allwein, Model-driven Engineering from Modular Monadic Semantics: Implementation Techniques Targeting Hardware and Software (PRE-PRINT). Proceedings of the IFIP Working Conference on Domain Specific Languages (DSL WC), Volume 5658 of Lecture Notes in Computer Science, pages 20-44. Springer-Verlag, July, 2009. - Jason Agron and David Andrews, Hardware Microkernels for Heterogeneous Manycore Systems. Proceedings of the Fifth International Workshop on Operating Systems Platforms for Embedded Real-Time Applications (OSPERT), Dublin, Ireland, June, 2009. - Miaoqing Huang, Harald Simmler, Olivier Serres, and Tarek El-Ghazawi, \"RDMS: A Hardware Task Scheduling Algorithm for Reconfigurable Computing,\" in Proceedings of the 16th Reconfigurable Architectures Workshop (RAW 2009), Rome, Italy, May 25-26, 2009. - Miaoqing Huang, Vikram K. Narayana, and Tarek El-Ghazawi, \"Efficient mapping of hardware tasks on reconfigurable computers using libraries of architecture variants,\" in Proceedings of the Seventeenth Annual IEEE Symposium on Field-Programmable Custom Computing Machines (FCCM'09), pp. 247-250, Napa, CA, USA, April 5-7, 2009. - Miaoqing Huang, Olivier Serres, Tarek El-Ghazawi, and Greg Newby, \"Parameterized Hardware Design on Reconfigurable Computers: An Image Registration Case Study\", in Proceedings of V Southern Conference on Programmable Logic (SPL 2009), pp.71-76, Sao Carlos, Brazil, April 1-3, 2009. ## 2008 - D. Andrews, Increasing Design Productivity for Next Generation Platform FPGA's , Presentation at the ICFPT08 Pre-Workshop on FPGA Design Productivity, December 2008 - Miaoqing Huang, Harald Simmler, Proshanta Saha, and Tarek El-Ghazawi, \"Hardware Task Scheduling Optimizations for Reconfigurable Computing,\" in Proceedings of the Second International Workshop on High-Performance Reconfigurable Computing Technology and Applications (HPRCTA'08), Austin, Texas, USA, Nov. 17, 2008. - Miaoqing Huang, Olivier Serres, Tarek El-Ghazawi, and Greg Newby, \"Implementing Image Registration Algorithms on Reconfigurable Computer,\" in Proceedings of 10th Military and Aerospace Programmable Logic Devices Conference (MAPLD 2008), Annapolis, Maryland, USA, Sept. 15-18, 2008. - D. Andrews, J. Agron, Modeling Abstractions for Next-Generation Reconfigurable Computing, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA) July 2008 - Miaoqing Huang, Ivan Gonzalez, Sergio Lopez-Buedo, and Tarek El-Ghazawi, \"A Framework to Improve IP Portability on Reconfigurable Computers,\" in Proceedings of The 10th International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA 2008), pp.191-197, Las Vegas, Nevada, USA, July 14-17, 2008. - Miaoqing Huang, Esam El-Araby, and Tarek El-Ghazawi, \"Divide-and-Conquer Approach for Designing Large-operand Functions on Reconfigurable Computers,\" in Proceedings of the 4th Reconfigurable Systems Summer Institute, 2008 (RSSI'08), Urbana, Illinois, USA, July 7-9, 2008. - Santner, S., Peck, W., Agron, J., and Andrews, D., Symmetric Multiprocessor Design for Hybrid CPU/FPGA SoCs, Proceedings of the 4th International Workshop on Applied Reconfigurable Computing (ARC 2008) in Lecture Notes in Computer Science, Springer-Verlag, Number 4943, pp. 99 - 110, 2008 - Proshanta Saha, Esam El-Araby, Miaoqing Huang, Mohamed Taher, Sergio Lopez-Buedo,Tarek El-Ghazawi, Chang Shu, Kris Gaj, Alan Michalski, and Duncan Buell, \"Portable library development for reconfigurable computing systems: A case study,\" Parallel Computing, vol.34, no.4+5, pp.245-260, May, 2008. - Elias Teodoro Silva Jr., David Andrews, Carlos Eduardo Pereira, and Flavio Rech Wagner An Infrastructure for Hardwdare-Software Co-Design of Embedded Real-Time Java Applications, Proceedings of the 11th IEEE International Symposium on Object-Oriented Real-Time Distributed Computing (ISORC 2008) pp. 273-280, May 2008. - Miaoqing Huang, Olivier Serres, Sergio Lopez-Buedo, Tarek El-Ghazawi, and Greg Newby, \"An Image Processing Architecture To Exploit I/O Bandwidth on Reconfigurable Computers,\" in Proceedings of IEEE IV Southern Conferece on Programmable Logic (SPL 2008), pp.257-260, Bariloche-Patagonia, Argentina, March 26-28, 2008. - Miaoqing Huang, Kris Gaj, Soonhak Kwon, and Tarek El-Ghazawi, \"An Optimized Hardware Architecture for the Montgomery Multiplication Algorithm,\" in Proceedings of The 11th International Workshop on Practice and Theory in Public Key Cryptography (PKC 2008), LNCS vol.4939, pp.214-228, March 9-12, 2008. - Tarek El-Ghazawi, Esam El-Araby, Miaoqing Huang, Kris Gaj, Volodymyr Kindratenko, and Duncan Buell, \"The promise of high-performance reconfigurable computing,\" IEEE Computer, vol.41, no.2, pp.69-76, Feb. 2008. - D. Andrews, R. Sass, E. Anderson, J. Agron, W. Peck, J. Stevens, F. Baijot, and E. Komp, Achieving Programming Model Abstractions For Reconﬁgurable Computing, IEEE Transactions on Very Large Scale Integration (VLSI) Systems, vol. 16, no. 1, pp. 34–44, January 2008. ## 2007 - Miaoqing Huang, Ivan Gonzalez, and Tarek El-Ghazawi, \"A Portable Memory Access Framework on Reconfigurable Computers,\" in Proceedings of IEEE 2007 International Conference on Field-Programmable Technology (ICFPT'07), pp. 333-336, December 12-14, 2007. - Thamer Abuyasin, Enabling Task Level Parallelism In Handel-C, Master's Thesis at the University of Kansas (December, 2007). Thesis and presentation slides. - Erik Anderson, Wesley Peck, Jim Stevens, Jason Agron, Fabrice Baijot, Seth Warn, and David Andrews, Supporting High-Level Language Semantics Within Hardware Resident Threads, 17th International Conference on Field Programmable Logic and Applications, August 2007. pp. 98-103. - Jim Stevens, Hybridthreads Compiler: Generation of Application Specific Hardware Thread Cores from C, Ph.D. Forum at the 17th International Conference on Field Programmable Logic and Applications, August 2007. - Erik Anderson, Abstracting the Hardware/Software Boundary through a Standard System Support Layer and Architecture, Ph.D. Dissertation at the University of Kansas (May, 2007). Thesis and presentation slides. - Erik Anderson, Wesley Peck, Jim Stevens, Jason Agron, Fabrice Baijot, Seth Warn, and David Andrews, Memory Hierarchy for MCSoPC Multithreaded Systems, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA) June 2007. - Ron Sass, William V. Kritikos, Andrew G. Schmidt, Srinivas Beeravolu, Parag Beeraka, Kushal Datta, David Andrews, Richard S. Miller, and Daniel Stanzione, Jr. Reconfigurable Computing Cluster (RCC) Project: Investigating the Feasibility of FPGA-Based Petascale Computing, Proceedings of the Fifteenth Annual IEEE Symposium on Field-Programmable Custom Computing Machines, Napa, CA. April 2007. - Miaoqing Huang, Tarek El-Ghazawi, Brian Larson, and Kris Gaj, \"Development of Block-Cipher Library for Reconfigurable Computers,\" in Proceedings of IEEE III Southern conference on Programmable Logic (SPL 2007), pp.191-194, February 26-28, 2007. ## 2006 - Jason Agron, Wesley Peck, Erik Anderson, David Andrews, Ed Komp, Ron Sass, Fabrice Baijot, and Jim Stevens, Run-Time Services for Hybrid CPU/FPGA Systems on Chip, Proceedings of the 27th IEEE International Real-Time Systems Symposium, Rio De Janeiro, Brazil, December 2006 pp. 3 - 12. File:Rtss06.pdf - Wesley Peck, Erik Anderson, Jason Agron, Jim Stevens, Fabrice Baijot, and David Andrews, Hthreads: A Computational Model for Reconfigurable Devices, Proceedings of the 16th International Conference on Field Programmable Logic and Applications (FPL) August 2006. pp. 885-888 File:Fpl06.pdf - David Andrews, Ron Sass, Erik Anderson, Jason Agron, Wesley Peck, Jim Stevens, Fabrice Baijot and Ed Komp,, The Case for High level Programming Models for Reconfigurable Computers, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA) June 2006. File:Ersa06.pdf - Jason Agron, Run-Time Scheduling Support for Hybrid CPU/FPGA SoCs, Master's Thesis at the University of Kansas (April, 2006). Thesis and presentation Slides - Erik Anderson, Jason Agron, Wesley Peck, Jim Stevens, Fabrice Baijot, Ed Komp, Ron Sass, David Andrews, Enabling a Uniform Programming Model Across the Software/Hardware Boundary, Proceedings of The Fourteenth Annual IEEE Symposium on Field-Programmable Custom Computing Machines, Napa Valley, CA, 24-26 April 2006. File:Fccm06.pdf ## 2005 - Razali Jidin, Extending the Thread Programming Model Across Hybrid FPGA/CPU Architectures, Ph.D. Dissertation at the University of Kansas (April, 2005). Thesis and presentations slides - David Andrews, Wesley Peck, Jason Agron, Keith Preston, Ed Komp, Mike Finley, Ron Sass, hthreads: A Hardware/Software Co-Designed Multithreaded RTOS Kernel, Proceedings of the 10th IEEE International Conference on Emerging Technologies and Factory Automation Facolta' di Ingegneria, Catania, Italy, 19-22 September 2005. File:Etfa05.pdf - David Andrews, Iain Bate, Thomas Nolte, Clara M. Otero Perez, Stefan M. Petters, Impact of Embedded Systems Evolution on RTOS Use and Design, Proceedings of the 1st International Workshop Operating System Platforms for Embedded Real-Time Applications (OSPERT'05) in conjunction with the 17th Euromicro International Conference on Real-Time Systems (ECRTS'05), p 13-19, Palma de Mallorca, Balearic Islands, Spain. File:Ospert.pdf - R. Jidin, D. Andrews, W. Peck, D. Chirpich, K. Stout, J. Gauch, Evaluation of the Hybrid Multithreading Programming Model using Image Processing Transform, Proceedings of the 12th Reconfigurable Architectures Workshop (RAW 2005), April 4-5, 2005, Denver, Colorado, USA. File:Hwimage.pdf ## 2004 - W. Peck, J. Agron, D. Andrews, M. Finley, E. Komp, Hardware/Software Co-Design of Operating System Services for Thread Management and Scheduling, In Proceedings of the 25th IEEE International Real-Time Systems Symposium, Works In Progress Session (RTSS, WIP 2004). Lisbon, Portugal, December 5-8, 2004. File:RTSS wesley.pdf - J. Agron, D. Andrews, M. Finley, E. Komp, W. Peck, FPGA Implementation of a Priority Scheduler Module, In Proceedings of the 25th IEEE International Real-Time Systems Symposium, Works In Progress Session (RTSS, WIP 2004). Lisbon, Portugal, December 5-8, 2004. File:RTSS FPGA Scheduler.pdf - R. Jidin, D. Andrews, D. Niehaus, W. Peck, Fast Synchronization Primitives for Hybrid CPU/FPGA Multithreading, In Proceedings of the 25th IEEE International Real-Time Systems Symposium, Works In Progress Session (RTSS, WIP 2004). Lisbon, Portugal, December 5-8, 2004. Online Proceedings (Pages 27-31) - Andrews, D., Niehaus, D., Jidin, R., Finley, M., Peck, W., Frisbee, M., Ortiz, J. Komp, E., Ashenden, P., Programming Models for Hybrid FPGA/CPU Computational Components: A Missing Link, IEEE Micro, July/August 2004. File:Micro.pdf - Jidin, R., Andrews, D., Niehaus, D., Implementing Multi Threaded System Support for Hybrid Computational Components, Proceedings of the International Conference on Engineering of Reconfigurable Systems and Algorithms (ERSA), June 2004, Las Vegas, Nevada. File:ERSA2004.pdf - Andrews, D., Niehaus, D., Jidin, R., Implementing the Thread Programming Model on Hybrid FPGA/CPU Computational Components, Proceedings of the 1st Workshop on Embedded Processor Architectures (WEPA) held in conjunction with the International Symposium on Computer Architecture, February, 2004, Madrid, Spain. File:Wepa.pdf - Andrews, D., Niehaus, D., and Ashenden, P., Programming Models for Hybrid FPGA/CPU Computational Components, IEEE Computer, January 2004. File:Computer.pdf - Michael Finley, Hardware/Software Codesign: Thread Manager, Master's Thesis at the University of Kansas (December, 2004). Thesis and presentation slides ## 2003 - Niehaus, D. , Andrews, D., Using the Multi-Threaded Computation Model as a Unifying Framework for Hardware-Software Co-Design and Implementation, Proceedings of the 9th International Workshop on Object-oriented Real-time Dependable Systems (WORDS 2003). File:Ku-words.pdf - David Andrews and Douglas Niehaus, Architectural Frameworks for MPP System on a Chip, Proceedings of the Third Workshop on Massively Parallel Processing (MPP), April 2003, Nice, France. File:Mpp.pdf ",
    "url": "/publications/",
    
    "relUrl": "/publications/"
  },"23": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": "# Weekly Schedule {% assign modules = site.modules | where: 'course', '4213' %} {% for module in modules %} {{ module }} {% endfor %} ",
    "url": "/classes/computer-architecture/schedule/",
    
    "relUrl": "/classes/computer-architecture/schedule/"
  },"24": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": "# Weekly Schedule | Week 1 8/21-8/25 | Lecture Topic | Assignment | :----------- | :------------------------------: | --------------------:| Mon | [Course Introduction](/modules/csce-4114/4114_intro_F23.pdf) | Read ch 1.1, 2.1,2.2: download [Vivado 2019.1](https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/archive.html) | Weds | [Course Introduction](/modules/csce-4114/4114_intro_F23.pdf) | | Fri | Embedded Systems Platforms | Homework #1 Assigned | **Week 2 8/28-9/1** | **Lecture Topic** | **Assignment** | Mon | Embedded Systems Platforms | | Weds | Embedded Programming | | Fri | Embedded Programming | | **Week 3 9/4-9/8** | **Lecture Topic** | **Assignment** | Mon | Labor Day | | Weds | Serial Communications | | Fri | UARTs | | **Week 4 9/11-9/15** | **Lecture Topic** | **Assignment** | Mon | UARTs | | Weds | UARTs | | Fri | Sampling | | **Week 5 9/18-9/22** | **Lecture Topic** | **Assignment** | Mon | A/D Conversion | | Weds | A/D Conversion | | Fri | A/D Conversion | | **Week 6 9/25-9/29** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 7 10/2-10/6** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 8 10/9-10/13** | **Lecture Topic** | **Assignment** | Mon | | Weds | **Midterm Review** | | Fri | **Midterm Exam** | | **Week 9 10/16-10/20** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 10 10/23-10/27** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 11 10/30-11/3** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 12 11/6-11/10** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 13 11/13-11/17** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 14 11/20-11/24** | **Lecture Topic** | **Assignment** | Mon | | Weds | Thanksgiving Break! | | Fri | Thanksgiving Break!| | **Week 15 11/27-12/1** | **Lecture Topic** | **Assignment** | Mon | | Weds | | Fri | | **Week 16 12/4-12/8** | **Lecture Topic** | **Assignment** | Mon | | Weds | Semester Review| All Materials Due Before Friday | Fri | Reading Day| | **Final 12/8** | **3:00pm - 5pm ** | Final is not comprehensive | ",
    "url": "/classes/embedded-systems/schedule/",
    
    "relUrl": "/classes/embedded-systems/schedule/"
  },"25": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": "# Weekly Schedule {% for schedule in site.schedules %} {{ schedule }} {% endfor %} ",
    "url": "/schedule/",
    
    "relUrl": "/schedule/"
  },"26": {
    "doc": "Staff",
    "title": "Staff",
    "content": "# Staff Staff information is stored in the `_staffers` directory and rendered according to the layout file, `_layouts/staffer.html`. ## Instructors {% assign instructors = site.staffers | where: 'role', 'Instructor' %} {% for staffer in instructors %} {{ staffer }} {% endfor %} {% assign teaching_assistants = site.staffers | where: 'role', 'Teaching Assistant' %} {% assign num_teaching_assistants = teaching_assistants | size %} {% if num_teaching_assistants != 0 %} ## Teaching Assistants {% for staffer in teaching_assistants %} {{ staffer }} {% endfor %} {% endif %} ",
    "url": "/staff/",
    
    "relUrl": "/staff/"
  },"27": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": " ",
    "url": "/classes/computer-architecture/syllabus/",
    
    "relUrl": "/classes/computer-architecture/syllabus/"
  },"28": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": "## Overview This course introduces students to the design and analysis of computer systems that interact with the built environment. Applications of these systems impact nearly every aspect of modern life. Examples include cell phones, smartwatches, home monitoring systems, medical devices, autonomous (and non-autonomous) vehicles, UAVs, airplanes, submarines and space vehicles. As part of the course, students will learn about architecture, software, and hardware aspects of embedded systems development. The design of systems is a complex multi-objective optimization task, and students will develop an understanding of how to work within the parameters given to meet constraints (e.g. real-time deadlines, memory, disk, connectivity, power, etc.). ## Textbook - Frank Vahid, Tony Givargis, Bailey Miller, Programming Embedded Systems, Zybook. - (Optional) Marilyn Wolf, Embedded System Interfacing: Design for the Internet-of-Things (IoT) and Cyber-Physical Systems (CPS), Elsevier; 2019 Edition. ## Lecture Topics | Topic | Coverage |:------------------------------------------------------------------------------- | --------:| Introduction to embedded systems | 1 week | SoC and Component Technologies | 1 week | System Programming and Interfacing (C programming, bit operators) | 2 weeks | Hardware Interfacing (GPIO) | 1 week | I/O Communications, Peripherals, Polling, Interrupts, Timers (UART, PIC, Timer) | 3 week | Sampling Theory and A/D Convertors | 2 weeks | Real Time Programming Models and Requirements | 2 weeks | Real Time Scheduling | 1 week | RTOS's (FreeRTOS) | 2 weeks | Selected topics (Trends, OS and Compiler for ES, etc ...) | 1 week | ## Laboratory Component This class has a laboratory component allowing students to gain hands-on experience with building an embedded system. The laboratories are structured towards a final class project. The final project may very from semester to semester. The most recent projects result in the students building an autonomous car that follows a track and avoids obstacles. ## Learning Outcomes - Describe the characteristics of embedded systems as well as the challenges related with their design - Summarize the key components of an embedded system as well as their interactions - Identify and formalize design goals (cost, power, time-to-market, etc ...) - Choose the right model and tools for capturing and analyze complex embedded systems - Conduct a project in team and present the results in a fundamental way - Evaluate a produced design and identify where improvements to the design could be made to improve one or more design parameters ## Grading | Activity | Weight |:-------- | --------:| 2 Exams | 30% each | Labs | 20% | Homework | 10% | Grading will be on a 90%-80%-70%-60% scale. Curving may be applied based on course average. ",
    "url": "/classes/embedded-systems/syllabus/",
    
    "relUrl": "/classes/embedded-systems/syllabus/"
  }
}
